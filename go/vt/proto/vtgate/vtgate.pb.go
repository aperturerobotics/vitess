// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.6.1
// source: github.com/dolthub/vitess/proto/dolthub/vt/vtgate.proto

package vtgate

import (
	base64 "encoding/base64"
	fmt "fmt"
	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	json "github.com/aperturerobotics/protobuf-go-lite/json"
	binlogdata "github.com/dolthub/vitess/go/vt/proto/binlogdata"
	query "github.com/dolthub/vitess/go/vt/proto/query"
	topodata "github.com/dolthub/vitess/go/vt/proto/topodata"
	vtrpc "github.com/dolthub/vitess/go/vt/proto/vtrpc"
	io "io"
	strconv "strconv"
	strings "strings"
)

//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// Data definitions for service vtgateservice.

// TransactionMode controls the execution of distributed transaction
// across multiple shards.
type TransactionMode int32

const (
	// UNSPECIFIED uses the transaction mode set by the VTGate flag 'transaction_mode'.
	TransactionMode_UNSPECIFIED TransactionMode = 0
	// SINGLE disallows distributed transactions.
	TransactionMode_SINGLE TransactionMode = 1
	// MULTI allows distributed transactions with best effort commit.
	TransactionMode_MULTI TransactionMode = 2
	// TWOPC is for distributed transactions with atomic commits.
	TransactionMode_TWOPC TransactionMode = 3
)

// Enum value maps for TransactionMode.
var (
	TransactionMode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "SINGLE",
		2: "MULTI",
		3: "TWOPC",
	}
	TransactionMode_value = map[string]int32{
		"UNSPECIFIED": 0,
		"SINGLE":      1,
		"MULTI":       2,
		"TWOPC":       3,
	}
)

func (x TransactionMode) Enum() *TransactionMode {
	p := new(TransactionMode)
	*p = x
	return p
}

func (x TransactionMode) String() string {
	name, valid := TransactionMode_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// CommitOrder is used to designate which of the ShardSessions
// get used for transactions.
type CommitOrder int32

const (
	// NORMAL is the default commit order.
	CommitOrder_NORMAL CommitOrder = 0
	// PRE is used to designate pre_sessions.
	CommitOrder_PRE CommitOrder = 1
	// POST is used to designate post_sessions.
	CommitOrder_POST CommitOrder = 2
	// AUTOCOMMIT is used to run the statement as autocommitted transaction.
	CommitOrder_AUTOCOMMIT CommitOrder = 3
)

// Enum value maps for CommitOrder.
var (
	CommitOrder_name = map[int32]string{
		0: "NORMAL",
		1: "PRE",
		2: "POST",
		3: "AUTOCOMMIT",
	}
	CommitOrder_value = map[string]int32{
		"NORMAL":     0,
		"PRE":        1,
		"POST":       2,
		"AUTOCOMMIT": 3,
	}
)

func (x CommitOrder) Enum() *CommitOrder {
	p := new(CommitOrder)
	*p = x
	return p
}

func (x CommitOrder) String() string {
	name, valid := CommitOrder_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Session objects are exchanged like cookies through various
// calls to VTGate. The behavior differs between V2 & V3 APIs.
// V3 APIs are Execute, ExecuteBatch and StreamExecute. All
// other APIs are V2. For the V3 APIs, the session
// must be sent with every call to Execute or ExecuteBatch.
// For the V2 APIs, Begin does not accept a session. It instead
// returns a brand new one with in_transaction set to true.
// After a call to Commit or Rollback, the session can be
// discarded. If you're not in a transaction, Session is
// an optional parameter for the V2 APIs.
type Session struct {
	unknownFields []byte
	// in_transaction is set to true if the session is in a transaction.
	InTransaction bool `protobuf:"varint,1,opt,name=in_transaction,json=inTransaction,proto3" json:"inTransaction,omitempty"`
	// shard_sessions keep track of per-shard transaction info.
	ShardSessions []*Session_ShardSession `protobuf:"bytes,2,rep,name=shard_sessions,json=shardSessions,proto3" json:"shardSessions,omitempty"`
	// single_db is deprecated. Use transaction_mode instead.
	// The value specifies if the transaction should be restricted
	// to a single shard.
	// TODO(sougou): remove in 3.1
	SingleDb bool `protobuf:"varint,3,opt,name=single_db,json=singleDb,proto3" json:"singleDb,omitempty"`
	// autocommit specifies if the session is in autocommit mode.
	// This is used only for V3.
	Autocommit bool `protobuf:"varint,4,opt,name=autocommit,proto3" json:"autocommit,omitempty"`
	// target_string is the target expressed as a string. Valid
	// names are: keyspace:shard@target, keyspace@target or @target.
	// This is used only for V3.
	TargetString string `protobuf:"bytes,5,opt,name=target_string,json=targetString,proto3" json:"targetString,omitempty"`
	// options is used only for V3.
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	// transaction_mode specifies the current transaction mode.
	TransactionMode TransactionMode `protobuf:"varint,7,opt,name=transaction_mode,json=transactionMode,proto3" json:"transactionMode,omitempty"`
	// warnings contains non-fatal warnings from the previous query
	Warnings []*query.QueryWarning `protobuf:"bytes,8,rep,name=warnings,proto3" json:"warnings,omitempty"`
	// pre_sessions contains sessions that have to be committed first.
	PreSessions []*Session_ShardSession `protobuf:"bytes,9,rep,name=pre_sessions,json=preSessions,proto3" json:"preSessions,omitempty"`
	// post_sessions contains sessions that have to be committed last.
	PostSessions []*Session_ShardSession `protobuf:"bytes,10,rep,name=post_sessions,json=postSessions,proto3" json:"postSessions,omitempty"`
}

func (x *Session) Reset() {
	*x = Session{}
}

func (*Session) ProtoMessage() {}

func (x *Session) GetInTransaction() bool {
	if x != nil {
		return x.InTransaction
	}
	return false
}

func (x *Session) GetShardSessions() []*Session_ShardSession {
	if x != nil {
		return x.ShardSessions
	}
	return nil
}

func (x *Session) GetSingleDb() bool {
	if x != nil {
		return x.SingleDb
	}
	return false
}

func (x *Session) GetAutocommit() bool {
	if x != nil {
		return x.Autocommit
	}
	return false
}

func (x *Session) GetTargetString() string {
	if x != nil {
		return x.TargetString
	}
	return ""
}

func (x *Session) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Session) GetTransactionMode() TransactionMode {
	if x != nil {
		return x.TransactionMode
	}
	return TransactionMode_UNSPECIFIED
}

func (x *Session) GetWarnings() []*query.QueryWarning {
	if x != nil {
		return x.Warnings
	}
	return nil
}

func (x *Session) GetPreSessions() []*Session_ShardSession {
	if x != nil {
		return x.PreSessions
	}
	return nil
}

func (x *Session) GetPostSessions() []*Session_ShardSession {
	if x != nil {
		return x.PostSessions
	}
	return nil
}

// ExecuteRequest is the payload to Execute.
type ExecuteRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType       topodata.TabletType   `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	NotInTransaction bool                  `protobuf:"varint,5,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"notInTransaction,omitempty"`
	KeyspaceShard    string                `protobuf:"bytes,6,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspaceShard,omitempty"`
	Options          *query.ExecuteOptions `protobuf:"bytes,7,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteRequest) Reset() {
	*x = ExecuteRequest{}
}

func (*ExecuteRequest) ProtoMessage() {}

func (x *ExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *ExecuteRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteRequest) GetNotInTransaction() bool {
	if x != nil {
		return x.NotInTransaction
	}
	return false
}

func (x *ExecuteRequest) GetKeyspaceShard() string {
	if x != nil {
		return x.KeyspaceShard
	}
	return ""
}

func (x *ExecuteRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteResponse is the returned value from Execute.
type ExecuteResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *ExecuteResponse) Reset() {
	*x = ExecuteResponse{}
}

func (*ExecuteResponse) ProtoMessage() {}

func (x *ExecuteResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// ExecuteShardsRequest is the payload to ExecuteShards.
type ExecuteShardsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to. A DML can only target one shard.
	Shards []string `protobuf:"bytes,5,rep,name=shards,proto3" json:"shards,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"notInTransaction,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteShardsRequest) Reset() {
	*x = ExecuteShardsRequest{}
}

func (*ExecuteShardsRequest) ProtoMessage() {}

func (x *ExecuteShardsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteShardsRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteShardsRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *ExecuteShardsRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *ExecuteShardsRequest) GetShards() []string {
	if x != nil {
		return x.Shards
	}
	return nil
}

func (x *ExecuteShardsRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteShardsRequest) GetNotInTransaction() bool {
	if x != nil {
		return x.NotInTransaction
	}
	return false
}

func (x *ExecuteShardsRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteShardsResponse is the returned value from ExecuteShards.
type ExecuteShardsResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *ExecuteShardsResponse) Reset() {
	*x = ExecuteShardsResponse{}
}

func (*ExecuteShardsResponse) ProtoMessage() {}

func (x *ExecuteShardsResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteShardsResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteShardsResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// ExecuteKeyspaceIdsRequest is the payload to ExecuteKeyspaceIds.
type ExecuteKeyspaceIdsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,5,rep,name=keyspace_ids,json=keyspaceIds,proto3" json:"keyspaceIds,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"notInTransaction,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteKeyspaceIdsRequest) Reset() {
	*x = ExecuteKeyspaceIdsRequest{}
}

func (*ExecuteKeyspaceIdsRequest) ProtoMessage() {}

func (x *ExecuteKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteKeyspaceIdsRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteKeyspaceIdsRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *ExecuteKeyspaceIdsRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *ExecuteKeyspaceIdsRequest) GetKeyspaceIds() [][]byte {
	if x != nil {
		return x.KeyspaceIds
	}
	return nil
}

func (x *ExecuteKeyspaceIdsRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteKeyspaceIdsRequest) GetNotInTransaction() bool {
	if x != nil {
		return x.NotInTransaction
	}
	return false
}

func (x *ExecuteKeyspaceIdsRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteKeyspaceIdsResponse is the returned value from ExecuteKeyspaceIds.
type ExecuteKeyspaceIdsResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *ExecuteKeyspaceIdsResponse) Reset() {
	*x = ExecuteKeyspaceIdsResponse{}
}

func (*ExecuteKeyspaceIdsResponse) ProtoMessage() {}

func (x *ExecuteKeyspaceIdsResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteKeyspaceIdsResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteKeyspaceIdsResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// ExecuteKeyRangesRequest is the payload to ExecuteKeyRanges.
type ExecuteKeyRangesRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// key_ranges contains the list of key ranges affected by this query.
	// Will be used to find the shards to send the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,5,rep,name=key_ranges,json=keyRanges,proto3" json:"keyRanges,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"notInTransaction,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteKeyRangesRequest) Reset() {
	*x = ExecuteKeyRangesRequest{}
}

func (*ExecuteKeyRangesRequest) ProtoMessage() {}

func (x *ExecuteKeyRangesRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteKeyRangesRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteKeyRangesRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *ExecuteKeyRangesRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *ExecuteKeyRangesRequest) GetKeyRanges() []*topodata.KeyRange {
	if x != nil {
		return x.KeyRanges
	}
	return nil
}

func (x *ExecuteKeyRangesRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteKeyRangesRequest) GetNotInTransaction() bool {
	if x != nil {
		return x.NotInTransaction
	}
	return false
}

func (x *ExecuteKeyRangesRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteKeyRangesResponse is the returned value from ExecuteKeyRanges.
type ExecuteKeyRangesResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *ExecuteKeyRangesResponse) Reset() {
	*x = ExecuteKeyRangesResponse{}
}

func (*ExecuteKeyRangesResponse) ProtoMessage() {}

func (x *ExecuteKeyRangesResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteKeyRangesResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteKeyRangesResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// ExecuteEntityIdsRequest is the payload to ExecuteEntityIds.
type ExecuteEntityIdsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// entity_column_name is the column name to use.
	EntityColumnName string `protobuf:"bytes,5,opt,name=entity_column_name,json=entityColumnName,proto3" json:"entityColumnName,omitempty"`
	// entity_keyspace_ids are pairs of entity_column_name values
	// associated with its corresponding keyspace_id.
	EntityKeyspaceIds []*ExecuteEntityIdsRequest_EntityId `protobuf:"bytes,6,rep,name=entity_keyspace_ids,json=entityKeyspaceIds,proto3" json:"entityKeyspaceIds,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,7,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,8,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"notInTransaction,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,9,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteEntityIdsRequest) Reset() {
	*x = ExecuteEntityIdsRequest{}
}

func (*ExecuteEntityIdsRequest) ProtoMessage() {}

func (x *ExecuteEntityIdsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteEntityIdsRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteEntityIdsRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *ExecuteEntityIdsRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *ExecuteEntityIdsRequest) GetEntityColumnName() string {
	if x != nil {
		return x.EntityColumnName
	}
	return ""
}

func (x *ExecuteEntityIdsRequest) GetEntityKeyspaceIds() []*ExecuteEntityIdsRequest_EntityId {
	if x != nil {
		return x.EntityKeyspaceIds
	}
	return nil
}

func (x *ExecuteEntityIdsRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteEntityIdsRequest) GetNotInTransaction() bool {
	if x != nil {
		return x.NotInTransaction
	}
	return false
}

func (x *ExecuteEntityIdsRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteEntityIdsResponse is the returned value from ExecuteEntityIds.
type ExecuteEntityIdsResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *ExecuteEntityIdsResponse) Reset() {
	*x = ExecuteEntityIdsResponse{}
}

func (*ExecuteEntityIdsResponse) ProtoMessage() {}

func (x *ExecuteEntityIdsResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteEntityIdsResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteEntityIdsResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// ExecuteBatchRequest is the payload to ExecuteBatch.
type ExecuteBatchRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// queries is a list of query and bind variables to execute.
	Queries []*query.BoundQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType    topodata.TabletType   `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	AsTransaction bool                  `protobuf:"varint,5,opt,name=as_transaction,json=asTransaction,proto3" json:"asTransaction,omitempty"`
	KeyspaceShard string                `protobuf:"bytes,6,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspaceShard,omitempty"`
	Options       *query.ExecuteOptions `protobuf:"bytes,7,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteBatchRequest) Reset() {
	*x = ExecuteBatchRequest{}
}

func (*ExecuteBatchRequest) ProtoMessage() {}

func (x *ExecuteBatchRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteBatchRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchRequest) GetQueries() []*query.BoundQuery {
	if x != nil {
		return x.Queries
	}
	return nil
}

func (x *ExecuteBatchRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteBatchRequest) GetAsTransaction() bool {
	if x != nil {
		return x.AsTransaction
	}
	return false
}

func (x *ExecuteBatchRequest) GetKeyspaceShard() string {
	if x != nil {
		return x.KeyspaceShard
	}
	return ""
}

func (x *ExecuteBatchRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteBatchResponse is the returned value from ExecuteBatch.
type ExecuteBatchResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// results contains the query results, only set if application level error is unset.
	Results []*query.ResultWithError `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
}

func (x *ExecuteBatchResponse) Reset() {
	*x = ExecuteBatchResponse{}
}

func (*ExecuteBatchResponse) ProtoMessage() {}

func (x *ExecuteBatchResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteBatchResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchResponse) GetResults() []*query.ResultWithError {
	if x != nil {
		return x.Results
	}
	return nil
}

// BoundShardQuery represents a single query request for the
// specified list of shards. This is used in a list for
// ExecuteBatchShardsRequest.
type BoundShardQuery struct {
	unknownFields []byte
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to. A DML can only target one shard.
	Shards []string `protobuf:"bytes,3,rep,name=shards,proto3" json:"shards,omitempty"`
}

func (x *BoundShardQuery) Reset() {
	*x = BoundShardQuery{}
}

func (*BoundShardQuery) ProtoMessage() {}

func (x *BoundShardQuery) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *BoundShardQuery) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *BoundShardQuery) GetShards() []string {
	if x != nil {
		return x.Shards
	}
	return nil
}

// ExecuteBatchShardsRequest is the payload to ExecuteBatchShards
type ExecuteBatchShardsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// queries carries all the queries to execute.
	Queries []*BoundShardQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose.
	// (this can be seen as adding a 'begin' before and 'commit' after the queries).
	// Only makes sense if tablet_type is master. If set, the Session is ignored.
	AsTransaction bool `protobuf:"varint,5,opt,name=as_transaction,json=asTransaction,proto3" json:"asTransaction,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteBatchShardsRequest) Reset() {
	*x = ExecuteBatchShardsRequest{}
}

func (*ExecuteBatchShardsRequest) ProtoMessage() {}

func (x *ExecuteBatchShardsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteBatchShardsRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchShardsRequest) GetQueries() []*BoundShardQuery {
	if x != nil {
		return x.Queries
	}
	return nil
}

func (x *ExecuteBatchShardsRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteBatchShardsRequest) GetAsTransaction() bool {
	if x != nil {
		return x.AsTransaction
	}
	return false
}

func (x *ExecuteBatchShardsRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteBatchShardsResponse is the returned value from ExecuteBatchShards.
type ExecuteBatchShardsResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Results []*query.QueryResult `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
}

func (x *ExecuteBatchShardsResponse) Reset() {
	*x = ExecuteBatchShardsResponse{}
}

func (*ExecuteBatchShardsResponse) ProtoMessage() {}

func (x *ExecuteBatchShardsResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteBatchShardsResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchShardsResponse) GetResults() []*query.QueryResult {
	if x != nil {
		return x.Results
	}
	return nil
}

// BoundKeyspaceIdQuery represents a single query request for the
// specified list of keyspace ids. This is used in a list for
// ExecuteBatchKeyspaceIdsRequest.
type BoundKeyspaceIdQuery struct {
	unknownFields []byte
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,3,rep,name=keyspace_ids,json=keyspaceIds,proto3" json:"keyspaceIds,omitempty"`
}

func (x *BoundKeyspaceIdQuery) Reset() {
	*x = BoundKeyspaceIdQuery{}
}

func (*BoundKeyspaceIdQuery) ProtoMessage() {}

func (x *BoundKeyspaceIdQuery) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *BoundKeyspaceIdQuery) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *BoundKeyspaceIdQuery) GetKeyspaceIds() [][]byte {
	if x != nil {
		return x.KeyspaceIds
	}
	return nil
}

// ExecuteBatchKeyspaceIdsRequest is the payload to ExecuteBatchKeyspaceId.
type ExecuteBatchKeyspaceIdsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session                `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	Queries []*BoundKeyspaceIdQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose.
	// (this can be seen as adding a 'begin' before and 'commit' after the queries).
	// Only makes sense if tablet_type is master. If set, the Session is ignored.
	AsTransaction bool `protobuf:"varint,5,opt,name=as_transaction,json=asTransaction,proto3" json:"asTransaction,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ExecuteBatchKeyspaceIdsRequest) Reset() {
	*x = ExecuteBatchKeyspaceIdsRequest{}
}

func (*ExecuteBatchKeyspaceIdsRequest) ProtoMessage() {}

func (x *ExecuteBatchKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteBatchKeyspaceIdsRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchKeyspaceIdsRequest) GetQueries() []*BoundKeyspaceIdQuery {
	if x != nil {
		return x.Queries
	}
	return nil
}

func (x *ExecuteBatchKeyspaceIdsRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *ExecuteBatchKeyspaceIdsRequest) GetAsTransaction() bool {
	if x != nil {
		return x.AsTransaction
	}
	return false
}

func (x *ExecuteBatchKeyspaceIdsRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ExecuteBatchKeyspaceIdsResponse is the returned value from ExecuteBatchKeyspaceId.
type ExecuteBatchKeyspaceIdsResponse struct {
	unknownFields []byte
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Results []*query.QueryResult `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
}

func (x *ExecuteBatchKeyspaceIdsResponse) Reset() {
	*x = ExecuteBatchKeyspaceIdsResponse{}
}

func (*ExecuteBatchKeyspaceIdsResponse) ProtoMessage() {}

func (x *ExecuteBatchKeyspaceIdsResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteBatchKeyspaceIdsResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchKeyspaceIdsResponse) GetResults() []*query.QueryResult {
	if x != nil {
		return x.Results
	}
	return nil
}

// StreamExecuteRequest is the payload to StreamExecute.
type StreamExecuteRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType    topodata.TabletType   `protobuf:"varint,3,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	KeyspaceShard string                `protobuf:"bytes,4,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspaceShard,omitempty"`
	Options       *query.ExecuteOptions `protobuf:"bytes,5,opt,name=options,proto3" json:"options,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,6,opt,name=session,proto3" json:"session,omitempty"`
}

func (x *StreamExecuteRequest) Reset() {
	*x = StreamExecuteRequest{}
}

func (*StreamExecuteRequest) ProtoMessage() {}

func (x *StreamExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *StreamExecuteRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *StreamExecuteRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *StreamExecuteRequest) GetKeyspaceShard() string {
	if x != nil {
		return x.KeyspaceShard
	}
	return ""
}

func (x *StreamExecuteRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *StreamExecuteRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// StreamExecuteResponse is the returned value from StreamExecute.
// The session is currently not returned because StreamExecute is
// not expected to modify it.
type StreamExecuteResponse struct {
	unknownFields []byte
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *StreamExecuteResponse) Reset() {
	*x = StreamExecuteResponse{}
}

func (*StreamExecuteResponse) ProtoMessage() {}

func (x *StreamExecuteResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// StreamExecuteShardsRequest is the payload to StreamExecuteShards.
type StreamExecuteShardsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to.
	Shards []string `protobuf:"bytes,4,rep,name=shards,proto3" json:"shards,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *StreamExecuteShardsRequest) Reset() {
	*x = StreamExecuteShardsRequest{}
}

func (*StreamExecuteShardsRequest) ProtoMessage() {}

func (x *StreamExecuteShardsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *StreamExecuteShardsRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *StreamExecuteShardsRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *StreamExecuteShardsRequest) GetShards() []string {
	if x != nil {
		return x.Shards
	}
	return nil
}

func (x *StreamExecuteShardsRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *StreamExecuteShardsRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// StreamExecuteShardsResponse is the returned value from StreamExecuteShards.
type StreamExecuteShardsResponse struct {
	unknownFields []byte
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *StreamExecuteShardsResponse) Reset() {
	*x = StreamExecuteShardsResponse{}
}

func (*StreamExecuteShardsResponse) ProtoMessage() {}

func (x *StreamExecuteShardsResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// StreamExecuteKeyspaceIdsRequest is the payload to StreamExecuteKeyspaceIds.
type StreamExecuteKeyspaceIdsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,4,rep,name=keyspace_ids,json=keyspaceIds,proto3" json:"keyspaceIds,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *StreamExecuteKeyspaceIdsRequest) Reset() {
	*x = StreamExecuteKeyspaceIdsRequest{}
}

func (*StreamExecuteKeyspaceIdsRequest) ProtoMessage() {}

func (x *StreamExecuteKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *StreamExecuteKeyspaceIdsRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *StreamExecuteKeyspaceIdsRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *StreamExecuteKeyspaceIdsRequest) GetKeyspaceIds() [][]byte {
	if x != nil {
		return x.KeyspaceIds
	}
	return nil
}

func (x *StreamExecuteKeyspaceIdsRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *StreamExecuteKeyspaceIdsRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// StreamExecuteKeyspaceIdsResponse is the returned value from StreamExecuteKeyspaceIds.
type StreamExecuteKeyspaceIdsResponse struct {
	unknownFields []byte
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *StreamExecuteKeyspaceIdsResponse) Reset() {
	*x = StreamExecuteKeyspaceIdsResponse{}
}

func (*StreamExecuteKeyspaceIdsResponse) ProtoMessage() {}

func (x *StreamExecuteKeyspaceIdsResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// StreamExecuteKeyRangesRequest is the payload to StreamExecuteKeyRanges.
type StreamExecuteKeyRangesRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// key_ranges contains the list of key ranges affected by this query.
	// Will be used to find the shards to send the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,4,rep,name=key_ranges,json=keyRanges,proto3" json:"keyRanges,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// options
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *StreamExecuteKeyRangesRequest) Reset() {
	*x = StreamExecuteKeyRangesRequest{}
}

func (*StreamExecuteKeyRangesRequest) ProtoMessage() {}

func (x *StreamExecuteKeyRangesRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *StreamExecuteKeyRangesRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *StreamExecuteKeyRangesRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *StreamExecuteKeyRangesRequest) GetKeyRanges() []*topodata.KeyRange {
	if x != nil {
		return x.KeyRanges
	}
	return nil
}

func (x *StreamExecuteKeyRangesRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *StreamExecuteKeyRangesRequest) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// StreamExecuteKeyRangesResponse is the returned value from StreamExecuteKeyRanges.
type StreamExecuteKeyRangesResponse struct {
	unknownFields []byte
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *StreamExecuteKeyRangesResponse) Reset() {
	*x = StreamExecuteKeyRangesResponse{}
}

func (*StreamExecuteKeyRangesResponse) ProtoMessage() {}

func (x *StreamExecuteKeyRangesResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// BeginRequest is the payload to Begin.
type BeginRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// single_db is deprecated. Use transaction_mode instead.
	// The value specifies if the transaction should be restricted
	// to a single database.
	// TODO(sougou): remove in 3.1
	SingleDb bool `protobuf:"varint,2,opt,name=single_db,json=singleDb,proto3" json:"singleDb,omitempty"`
}

func (x *BeginRequest) Reset() {
	*x = BeginRequest{}
}

func (*BeginRequest) ProtoMessage() {}

func (x *BeginRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *BeginRequest) GetSingleDb() bool {
	if x != nil {
		return x.SingleDb
	}
	return false
}

// BeginResponse is the returned value from Begin.
type BeginResponse struct {
	unknownFields []byte
	// session is the initial session information to use for subsequent queries.
	Session *Session `protobuf:"bytes,1,opt,name=session,proto3" json:"session,omitempty"`
}

func (x *BeginResponse) Reset() {
	*x = BeginResponse{}
}

func (*BeginResponse) ProtoMessage() {}

func (x *BeginResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// CommitRequest is the payload to Commit.
type CommitRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data to commit.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// atomic is deprecated. Use transaction_mode instead.
	// The value specifies if the commit should go through the
	// 2PC workflow to ensure atomicity.
	// TODO(sougou): remove in 3.1
	Atomic bool `protobuf:"varint,3,opt,name=atomic,proto3" json:"atomic,omitempty"`
}

func (x *CommitRequest) Reset() {
	*x = CommitRequest{}
}

func (*CommitRequest) ProtoMessage() {}

func (x *CommitRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *CommitRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *CommitRequest) GetAtomic() bool {
	if x != nil {
		return x.Atomic
	}
	return false
}

// CommitResponse is the returned value from Commit.
type CommitResponse struct {
	unknownFields []byte
}

func (x *CommitResponse) Reset() {
	*x = CommitResponse{}
}

func (*CommitResponse) ProtoMessage() {}

// RollbackRequest is the payload to Rollback.
type RollbackRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// session carries the current transaction data to rollback.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
}

func (x *RollbackRequest) Reset() {
	*x = RollbackRequest{}
}

func (*RollbackRequest) ProtoMessage() {}

func (x *RollbackRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *RollbackRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// RollbackResponse is the returned value from Rollback.
type RollbackResponse struct {
	unknownFields []byte
}

func (x *RollbackResponse) Reset() {
	*x = RollbackResponse{}
}

func (*RollbackResponse) ProtoMessage() {}

// ResolveTransactionRequest is the payload to ResolveTransaction.
type ResolveTransactionRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// dtid is the dtid of the transaction to be resolved.
	Dtid string `protobuf:"bytes,2,opt,name=dtid,proto3" json:"dtid,omitempty"`
}

func (x *ResolveTransactionRequest) Reset() {
	*x = ResolveTransactionRequest{}
}

func (*ResolveTransactionRequest) ProtoMessage() {}

func (x *ResolveTransactionRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ResolveTransactionRequest) GetDtid() string {
	if x != nil {
		return x.Dtid
	}
	return ""
}

// MessageStreamRequest is the request payload for MessageStream.
type MessageStreamRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shard to target the query to, for unsharded keyspaces.
	Shard string `protobuf:"bytes,3,opt,name=shard,proto3" json:"shard,omitempty"`
	// KeyRange to target the query to, for sharded keyspaces.
	KeyRange *topodata.KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"keyRange,omitempty"`
	// name is the message table name.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *MessageStreamRequest) Reset() {
	*x = MessageStreamRequest{}
}

func (*MessageStreamRequest) ProtoMessage() {}

func (x *MessageStreamRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *MessageStreamRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *MessageStreamRequest) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *MessageStreamRequest) GetKeyRange() *topodata.KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *MessageStreamRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// MessageAckRequest is the request payload for MessageAck.
type MessageAckRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// keyspace to target the message to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// name is the message table name.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// ids is the list of ids to ack.
	Ids []*query.Value `protobuf:"bytes,4,rep,name=ids,proto3" json:"ids,omitempty"`
}

func (x *MessageAckRequest) Reset() {
	*x = MessageAckRequest{}
}

func (*MessageAckRequest) ProtoMessage() {}

func (x *MessageAckRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *MessageAckRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *MessageAckRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MessageAckRequest) GetIds() []*query.Value {
	if x != nil {
		return x.Ids
	}
	return nil
}

// IdKeyspaceId represents an id and keyspace_id pair.
// The kesypace_id represents the routing info for id.
type IdKeyspaceId struct {
	unknownFields []byte
	// id represents the message id.
	Id *query.Value `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// keyspace_id is the associated keyspace_id for the id.
	KeyspaceId []byte `protobuf:"bytes,2,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspaceId,omitempty"`
}

func (x *IdKeyspaceId) Reset() {
	*x = IdKeyspaceId{}
}

func (*IdKeyspaceId) ProtoMessage() {}

func (x *IdKeyspaceId) GetId() *query.Value {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *IdKeyspaceId) GetKeyspaceId() []byte {
	if x != nil {
		return x.KeyspaceId
	}
	return nil
}

// MessageAckKeyspaceIdsRequest is the payload to MessageAckKeyspaceIds.
type MessageAckKeyspaceIdsRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// Optional keyspace for message table.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// name is the message table name.
	Name          string          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	IdKeyspaceIds []*IdKeyspaceId `protobuf:"bytes,4,rep,name=id_keyspace_ids,json=idKeyspaceIds,proto3" json:"idKeyspaceIds,omitempty"`
}

func (x *MessageAckKeyspaceIdsRequest) Reset() {
	*x = MessageAckKeyspaceIdsRequest{}
}

func (*MessageAckKeyspaceIdsRequest) ProtoMessage() {}

func (x *MessageAckKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *MessageAckKeyspaceIdsRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *MessageAckKeyspaceIdsRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MessageAckKeyspaceIdsRequest) GetIdKeyspaceIds() []*IdKeyspaceId {
	if x != nil {
		return x.IdKeyspaceIds
	}
	return nil
}

// ResolveTransactionResponse is the returned value from Rollback.
type ResolveTransactionResponse struct {
	unknownFields []byte
}

func (x *ResolveTransactionResponse) Reset() {
	*x = ResolveTransactionResponse{}
}

func (*ResolveTransactionResponse) ProtoMessage() {}

// SplitQueryRequest is the payload to SplitQuery.
//
// SplitQuery takes a "SELECT" query and generates a list of queries called
// "query-parts". Each query-part consists of the original query with an
// added WHERE clause that restricts the query-part to operate only on
// rows whose values in the columns listed in the "split_column" field
// of the request (see below) are in a particular range.
//
// It is guaranteed that the set of rows obtained from
// executing each query-part on a database snapshot
// and merging (without deduping) the results is equal to the set of rows
// obtained from executing the original query on the same snapshot
// with the rows containing NULL values in any of the split_column's excluded.
//
// This is typically called by the MapReduce master when reading from Vitess.
// There it's desirable that the sets of rows returned by the query-parts
// have roughly the same size.
type SplitQueryRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// The query and bind variables to produce splits for.
	// The given query must be a simple query of the form
	// SELECT <cols> FROM <table> WHERE <filter>.
	// It must not contain subqueries nor any of the keywords
	// JOIN, GROUP BY, ORDER BY, LIMIT, DISTINCT.
	// Furthermore, <table> must be a single "concrete" table.
	// It cannot be a view.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// Each generated query-part will be restricted to rows whose values
	// in the columns listed in this field are in a particular range.
	// The list of columns named here must be a prefix of the list of
	// columns defining some index or primary key of the table
	// referenced in 'query'. For many tables using the primary key columns
	// (in order) is sufficient and this is the default if this field is omitted.
	// See the comment on the 'algorithm' field for more restrictions and
	// information.
	SplitColumn []string `protobuf:"bytes,4,rep,name=split_column,json=splitColumn,proto3" json:"splitColumn,omitempty"`
	// You can specify either an estimate of the number of query-parts to
	// generate or an estimate of the number of rows each query-part should
	// return.
	// Thus, exactly one of split_count or num_rows_per_query_part
	// should be nonzero.
	// The non-given parameter is calculated from the given parameter
	// using the formula: split_count * num_rows_per_query_pary = table_size,
	// where table_size is an approximation of the number of rows in the
	// table.
	// Note that if "split_count" is given it is regarded as an estimate.
	// The number of query-parts returned may differ slightly (in particular,
	// if it's not a whole multiple of the number of vitess shards).
	SplitCount          int64 `protobuf:"varint,5,opt,name=split_count,json=splitCount,proto3" json:"splitCount,omitempty"`
	NumRowsPerQueryPart int64 `protobuf:"varint,6,opt,name=num_rows_per_query_part,json=numRowsPerQueryPart,proto3" json:"numRowsPerQueryPart,omitempty"`
	// The algorithm to use to split the query. The split algorithm is performed
	// on each database shard in parallel. The lists of query-parts generated
	// by the shards are merged and returned to the caller.
	// Two algorithms are supported:
	//
	//	EQUAL_SPLITS
	//	  If this algorithm is selected then only the first 'split_column' given
	//	  is used (or the first primary key column if the 'split_column' field is
	//	  empty). In the rest of this algorithm's description, we refer to
	//	  this column as "the split column".
	//	  The split column must have numeric type (integral or floating point).
	//	  The algorithm works by taking the interval [min, max], where min and
	//	  max are the minimum and maximum values of the split column in
	//	  the table-shard, respectively, and partitioning it into 'split_count'
	//	  sub-intervals of equal size. The added WHERE clause of each query-part
	//	  restricts that part to rows whose value in the split column belongs to
	//	  a particular sub-interval. This is fast, but requires that the
	//	  distribution of values of the split column be uniform in [min, max]
	//	  for the number of rows returned by each query part to be roughly the
	//	  same.
	//	FULL_SCAN
	//	  If this algorithm is used then the split_column must be the primary key
	//	  columns (in order).
	//	  This algorithm performs a full-scan of the table-shard referenced
	//	  in 'query' to get "boundary" rows that are num_rows_per_query_part
	//	  apart when the table is ordered by the columns listed in
	//	  'split_column'. It then restricts each query-part to the rows
	//	  located between two successive boundary rows.
	//	  This algorithm supports multiple split_column's of any type,
	//	  but is slower than EQUAL_SPLITS.
	Algorithm query.SplitQueryRequest_Algorithm `protobuf:"varint,7,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	// TODO(erez): This field is no longer used by the server code.
	// Remove this field after this new server code is released to prod.
	// We must keep it for now, so that clients can still send it to the old
	// server code currently in production.
	UseSplitQueryV2 bool `protobuf:"varint,8,opt,name=use_split_query_v2,json=useSplitQueryV2,proto3" json:"useSplitQueryV2,omitempty"`
}

func (x *SplitQueryRequest) Reset() {
	*x = SplitQueryRequest{}
}

func (*SplitQueryRequest) ProtoMessage() {}

func (x *SplitQueryRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *SplitQueryRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *SplitQueryRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *SplitQueryRequest) GetSplitColumn() []string {
	if x != nil {
		return x.SplitColumn
	}
	return nil
}

func (x *SplitQueryRequest) GetSplitCount() int64 {
	if x != nil {
		return x.SplitCount
	}
	return 0
}

func (x *SplitQueryRequest) GetNumRowsPerQueryPart() int64 {
	if x != nil {
		return x.NumRowsPerQueryPart
	}
	return 0
}

func (x *SplitQueryRequest) GetAlgorithm() query.SplitQueryRequest_Algorithm {
	if x != nil {
		return x.Algorithm
	}
	return query.SplitQueryRequest_Algorithm(0)
}

func (x *SplitQueryRequest) GetUseSplitQueryV2() bool {
	if x != nil {
		return x.UseSplitQueryV2
	}
	return false
}

// SplitQueryResponse is the returned value from SplitQuery.
type SplitQueryResponse struct {
	unknownFields []byte
	// splits contains the queries to run to fetch the entire data set.
	Splits []*SplitQueryResponse_Part `protobuf:"bytes,1,rep,name=splits,proto3" json:"splits,omitempty"`
}

func (x *SplitQueryResponse) Reset() {
	*x = SplitQueryResponse{}
}

func (*SplitQueryResponse) ProtoMessage() {}

func (x *SplitQueryResponse) GetSplits() []*SplitQueryResponse_Part {
	if x != nil {
		return x.Splits
	}
	return nil
}

// GetSrvKeyspaceRequest is the payload to GetSrvKeyspace.
type GetSrvKeyspaceRequest struct {
	unknownFields []byte
	// keyspace name to fetch.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
}

func (x *GetSrvKeyspaceRequest) Reset() {
	*x = GetSrvKeyspaceRequest{}
}

func (*GetSrvKeyspaceRequest) ProtoMessage() {}

func (x *GetSrvKeyspaceRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

// GetSrvKeyspaceResponse is the returned value from GetSrvKeyspace.
type GetSrvKeyspaceResponse struct {
	unknownFields []byte
	// srv_keyspace is the topology object for the SrvKeyspace.
	SrvKeyspace *topodata.SrvKeyspace `protobuf:"bytes,1,opt,name=srv_keyspace,json=srvKeyspace,proto3" json:"srvKeyspace,omitempty"`
}

func (x *GetSrvKeyspaceResponse) Reset() {
	*x = GetSrvKeyspaceResponse{}
}

func (*GetSrvKeyspaceResponse) ProtoMessage() {}

func (x *GetSrvKeyspaceResponse) GetSrvKeyspace() *topodata.SrvKeyspace {
	if x != nil {
		return x.SrvKeyspace
	}
	return nil
}

// VStreamRequest is the payload for VStream.
type VStreamRequest struct {
	unknownFields []byte
	CallerId      *vtrpc.CallerID     `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	TabletType    topodata.TabletType `protobuf:"varint,2,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// position specifies the starting point of the bin log positions
	// as well as the keyspace-shards to pull events from.
	// position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
	Vgtid  *binlogdata.VGtid  `protobuf:"bytes,3,opt,name=vgtid,proto3" json:"vgtid,omitempty"`
	Filter *binlogdata.Filter `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
}

func (x *VStreamRequest) Reset() {
	*x = VStreamRequest{}
}

func (*VStreamRequest) ProtoMessage() {}

func (x *VStreamRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *VStreamRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *VStreamRequest) GetVgtid() *binlogdata.VGtid {
	if x != nil {
		return x.Vgtid
	}
	return nil
}

func (x *VStreamRequest) GetFilter() *binlogdata.Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

// VStreamResponse is streamed by VStream.
type VStreamResponse struct {
	unknownFields []byte
	Events        []*binlogdata.VEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
}

func (x *VStreamResponse) Reset() {
	*x = VStreamResponse{}
}

func (*VStreamResponse) ProtoMessage() {}

func (x *VStreamResponse) GetEvents() []*binlogdata.VEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

// UpdateStreamRequest is the payload to UpdateStream.
type UpdateStreamRequest struct {
	unknownFields []byte
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"callerId,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shard to target the query to, for unsharded keyspaces.
	Shard string `protobuf:"bytes,3,opt,name=shard,proto3" json:"shard,omitempty"`
	// KeyRange to target the query to, for sharded keyspaces.
	KeyRange *topodata.KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"keyRange,omitempty"`
	// tablet_type is the type of tablets that this request is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// timestamp is the timestamp to start the stream from.  It is
	// unused is event is set, and we are only streaming from the shard
	// described by event.shard.
	Timestamp int64 `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// event is the event to start the stream from.
	// Note it is only used if we are streaming from exactly the same shard
	// as this event was coming from. Otherwise we can't use this event,
	// and will use the timestamp as a starting point.
	Event *query.EventToken `protobuf:"bytes,7,opt,name=event,proto3" json:"event,omitempty"`
}

func (x *UpdateStreamRequest) Reset() {
	*x = UpdateStreamRequest{}
}

func (*UpdateStreamRequest) ProtoMessage() {}

func (x *UpdateStreamRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *UpdateStreamRequest) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *UpdateStreamRequest) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *UpdateStreamRequest) GetKeyRange() *topodata.KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *UpdateStreamRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *UpdateStreamRequest) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *UpdateStreamRequest) GetEvent() *query.EventToken {
	if x != nil {
		return x.Event
	}
	return nil
}

// UpdateStreamResponse is streamed by UpdateStream.
type UpdateStreamResponse struct {
	unknownFields []byte
	// event is one event from the stream.
	Event *query.StreamEvent `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	// resume_timestamp is the timestamp to resume streaming from if the
	// client is interrupted. If the Update Stream only goes to one
	// shard, this is equal to event.timestamp. If the Update Stream
	// goes to multiple shards and aggregates, this is the minimum value
	// of the current timestamp for all shards.
	ResumeTimestamp int64 `protobuf:"varint,2,opt,name=resume_timestamp,json=resumeTimestamp,proto3" json:"resumeTimestamp,omitempty"`
}

func (x *UpdateStreamResponse) Reset() {
	*x = UpdateStreamResponse{}
}

func (*UpdateStreamResponse) ProtoMessage() {}

func (x *UpdateStreamResponse) GetEvent() *query.StreamEvent {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *UpdateStreamResponse) GetResumeTimestamp() int64 {
	if x != nil {
		return x.ResumeTimestamp
	}
	return 0
}

type Session_ShardSession struct {
	unknownFields []byte
	Target        *query.Target `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	TransactionId int64         `protobuf:"varint,2,opt,name=transaction_id,json=transactionId,proto3" json:"transactionId,omitempty"`
}

func (x *Session_ShardSession) Reset() {
	*x = Session_ShardSession{}
}

func (*Session_ShardSession) ProtoMessage() {}

func (x *Session_ShardSession) GetTarget() *query.Target {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *Session_ShardSession) GetTransactionId() int64 {
	if x != nil {
		return x.TransactionId
	}
	return 0
}

type ExecuteEntityIdsRequest_EntityId struct {
	unknownFields []byte
	// type is the type of the entity's value. Can be NULL_TYPE.
	Type query.Type `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// value is the value for the entity. Not set if type is NULL_TYPE.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// keyspace_id is the associated keyspace_id for the entity.
	KeyspaceId []byte `protobuf:"bytes,3,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspaceId,omitempty"`
}

func (x *ExecuteEntityIdsRequest_EntityId) Reset() {
	*x = ExecuteEntityIdsRequest_EntityId{}
}

func (*ExecuteEntityIdsRequest_EntityId) ProtoMessage() {}

func (x *ExecuteEntityIdsRequest_EntityId) GetType() query.Type {
	if x != nil {
		return x.Type
	}
	return query.Type(0)
}

func (x *ExecuteEntityIdsRequest_EntityId) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *ExecuteEntityIdsRequest_EntityId) GetKeyspaceId() []byte {
	if x != nil {
		return x.KeyspaceId
	}
	return nil
}

type SplitQueryResponse_KeyRangePart struct {
	unknownFields []byte
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// key ranges to target the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,2,rep,name=key_ranges,json=keyRanges,proto3" json:"keyRanges,omitempty"`
}

func (x *SplitQueryResponse_KeyRangePart) Reset() {
	*x = SplitQueryResponse_KeyRangePart{}
}

func (*SplitQueryResponse_KeyRangePart) ProtoMessage() {}

func (x *SplitQueryResponse_KeyRangePart) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *SplitQueryResponse_KeyRangePart) GetKeyRanges() []*topodata.KeyRange {
	if x != nil {
		return x.KeyRanges
	}
	return nil
}

type SplitQueryResponse_ShardPart struct {
	unknownFields []byte
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to.
	Shards []string `protobuf:"bytes,2,rep,name=shards,proto3" json:"shards,omitempty"`
}

func (x *SplitQueryResponse_ShardPart) Reset() {
	*x = SplitQueryResponse_ShardPart{}
}

func (*SplitQueryResponse_ShardPart) ProtoMessage() {}

func (x *SplitQueryResponse_ShardPart) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *SplitQueryResponse_ShardPart) GetShards() []string {
	if x != nil {
		return x.Shards
	}
	return nil
}

type SplitQueryResponse_Part struct {
	unknownFields []byte
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// key_range_part is set if the query should be executed by
	// ExecuteKeyRanges.
	KeyRangePart *SplitQueryResponse_KeyRangePart `protobuf:"bytes,2,opt,name=key_range_part,json=keyRangePart,proto3" json:"keyRangePart,omitempty"`
	// shard_part is set if the query should be executed by ExecuteShards.
	ShardPart *SplitQueryResponse_ShardPart `protobuf:"bytes,3,opt,name=shard_part,json=shardPart,proto3" json:"shardPart,omitempty"`
	// size is the approximate number of rows this query will return.
	Size int64 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *SplitQueryResponse_Part) Reset() {
	*x = SplitQueryResponse_Part{}
}

func (*SplitQueryResponse_Part) ProtoMessage() {}

func (x *SplitQueryResponse_Part) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *SplitQueryResponse_Part) GetKeyRangePart() *SplitQueryResponse_KeyRangePart {
	if x != nil {
		return x.KeyRangePart
	}
	return nil
}

func (x *SplitQueryResponse_Part) GetShardPart() *SplitQueryResponse_ShardPart {
	if x != nil {
		return x.ShardPart
	}
	return nil
}

func (x *SplitQueryResponse_Part) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (m *Session_ShardSession) CloneVT() *Session_ShardSession {
	if m == nil {
		return (*Session_ShardSession)(nil)
	}
	r := new(Session_ShardSession)
	r.TransactionId = m.TransactionId
	if rhs := m.Target; rhs != nil {
		r.Target = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Session_ShardSession) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Session) CloneVT() *Session {
	if m == nil {
		return (*Session)(nil)
	}
	r := new(Session)
	r.InTransaction = m.InTransaction
	r.SingleDb = m.SingleDb
	r.Autocommit = m.Autocommit
	r.TargetString = m.TargetString
	r.TransactionMode = m.TransactionMode
	if rhs := m.ShardSessions; rhs != nil {
		tmpContainer := make([]*Session_ShardSession, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ShardSessions = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if rhs := m.Warnings; rhs != nil {
		tmpContainer := make([]*query.QueryWarning, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Warnings = tmpContainer
	}
	if rhs := m.PreSessions; rhs != nil {
		tmpContainer := make([]*Session_ShardSession, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.PreSessions = tmpContainer
	}
	if rhs := m.PostSessions; rhs != nil {
		tmpContainer := make([]*Session_ShardSession, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.PostSessions = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Session) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteRequest) CloneVT() *ExecuteRequest {
	if m == nil {
		return (*ExecuteRequest)(nil)
	}
	r := new(ExecuteRequest)
	r.Session = m.Session.CloneVT()
	r.TabletType = m.TabletType
	r.NotInTransaction = m.NotInTransaction
	r.KeyspaceShard = m.KeyspaceShard
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteResponse) CloneVT() *ExecuteResponse {
	if m == nil {
		return (*ExecuteResponse)(nil)
	}
	r := new(ExecuteResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteShardsRequest) CloneVT() *ExecuteShardsRequest {
	if m == nil {
		return (*ExecuteShardsRequest)(nil)
	}
	r := new(ExecuteShardsRequest)
	r.Session = m.Session.CloneVT()
	r.Keyspace = m.Keyspace
	r.TabletType = m.TabletType
	r.NotInTransaction = m.NotInTransaction
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.Shards; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Shards = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteShardsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteShardsResponse) CloneVT() *ExecuteShardsResponse {
	if m == nil {
		return (*ExecuteShardsResponse)(nil)
	}
	r := new(ExecuteShardsResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteShardsResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteKeyspaceIdsRequest) CloneVT() *ExecuteKeyspaceIdsRequest {
	if m == nil {
		return (*ExecuteKeyspaceIdsRequest)(nil)
	}
	r := new(ExecuteKeyspaceIdsRequest)
	r.Session = m.Session.CloneVT()
	r.Keyspace = m.Keyspace
	r.TabletType = m.TabletType
	r.NotInTransaction = m.NotInTransaction
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.KeyspaceIds; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.KeyspaceIds = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteKeyspaceIdsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteKeyspaceIdsResponse) CloneVT() *ExecuteKeyspaceIdsResponse {
	if m == nil {
		return (*ExecuteKeyspaceIdsResponse)(nil)
	}
	r := new(ExecuteKeyspaceIdsResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteKeyspaceIdsResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteKeyRangesRequest) CloneVT() *ExecuteKeyRangesRequest {
	if m == nil {
		return (*ExecuteKeyRangesRequest)(nil)
	}
	r := new(ExecuteKeyRangesRequest)
	r.Session = m.Session.CloneVT()
	r.Keyspace = m.Keyspace
	r.TabletType = m.TabletType
	r.NotInTransaction = m.NotInTransaction
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.KeyRanges; rhs != nil {
		tmpContainer := make([]*topodata.KeyRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.KeyRanges = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteKeyRangesRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteKeyRangesResponse) CloneVT() *ExecuteKeyRangesResponse {
	if m == nil {
		return (*ExecuteKeyRangesResponse)(nil)
	}
	r := new(ExecuteKeyRangesResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteKeyRangesResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteEntityIdsRequest_EntityId) CloneVT() *ExecuteEntityIdsRequest_EntityId {
	if m == nil {
		return (*ExecuteEntityIdsRequest_EntityId)(nil)
	}
	r := new(ExecuteEntityIdsRequest_EntityId)
	r.Type = m.Type
	if rhs := m.Value; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Value = tmpBytes
	}
	if rhs := m.KeyspaceId; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.KeyspaceId = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteEntityIdsRequest_EntityId) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteEntityIdsRequest) CloneVT() *ExecuteEntityIdsRequest {
	if m == nil {
		return (*ExecuteEntityIdsRequest)(nil)
	}
	r := new(ExecuteEntityIdsRequest)
	r.Session = m.Session.CloneVT()
	r.Keyspace = m.Keyspace
	r.EntityColumnName = m.EntityColumnName
	r.TabletType = m.TabletType
	r.NotInTransaction = m.NotInTransaction
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.EntityKeyspaceIds; rhs != nil {
		tmpContainer := make([]*ExecuteEntityIdsRequest_EntityId, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.EntityKeyspaceIds = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteEntityIdsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteEntityIdsResponse) CloneVT() *ExecuteEntityIdsResponse {
	if m == nil {
		return (*ExecuteEntityIdsResponse)(nil)
	}
	r := new(ExecuteEntityIdsResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteEntityIdsResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteBatchRequest) CloneVT() *ExecuteBatchRequest {
	if m == nil {
		return (*ExecuteBatchRequest)(nil)
	}
	r := new(ExecuteBatchRequest)
	r.Session = m.Session.CloneVT()
	r.TabletType = m.TabletType
	r.AsTransaction = m.AsTransaction
	r.KeyspaceShard = m.KeyspaceShard
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Queries; rhs != nil {
		tmpContainer := make([]*query.BoundQuery, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Queries = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteBatchRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteBatchResponse) CloneVT() *ExecuteBatchResponse {
	if m == nil {
		return (*ExecuteBatchResponse)(nil)
	}
	r := new(ExecuteBatchResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Results; rhs != nil {
		tmpContainer := make([]*query.ResultWithError, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Results = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteBatchResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *BoundShardQuery) CloneVT() *BoundShardQuery {
	if m == nil {
		return (*BoundShardQuery)(nil)
	}
	r := new(BoundShardQuery)
	r.Keyspace = m.Keyspace
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.Shards; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Shards = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *BoundShardQuery) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteBatchShardsRequest) CloneVT() *ExecuteBatchShardsRequest {
	if m == nil {
		return (*ExecuteBatchShardsRequest)(nil)
	}
	r := new(ExecuteBatchShardsRequest)
	r.Session = m.Session.CloneVT()
	r.TabletType = m.TabletType
	r.AsTransaction = m.AsTransaction
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Queries; rhs != nil {
		tmpContainer := make([]*BoundShardQuery, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Queries = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteBatchShardsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteBatchShardsResponse) CloneVT() *ExecuteBatchShardsResponse {
	if m == nil {
		return (*ExecuteBatchShardsResponse)(nil)
	}
	r := new(ExecuteBatchShardsResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Results; rhs != nil {
		tmpContainer := make([]*query.QueryResult, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Results = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteBatchShardsResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *BoundKeyspaceIdQuery) CloneVT() *BoundKeyspaceIdQuery {
	if m == nil {
		return (*BoundKeyspaceIdQuery)(nil)
	}
	r := new(BoundKeyspaceIdQuery)
	r.Keyspace = m.Keyspace
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.KeyspaceIds; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.KeyspaceIds = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *BoundKeyspaceIdQuery) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteBatchKeyspaceIdsRequest) CloneVT() *ExecuteBatchKeyspaceIdsRequest {
	if m == nil {
		return (*ExecuteBatchKeyspaceIdsRequest)(nil)
	}
	r := new(ExecuteBatchKeyspaceIdsRequest)
	r.Session = m.Session.CloneVT()
	r.TabletType = m.TabletType
	r.AsTransaction = m.AsTransaction
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Queries; rhs != nil {
		tmpContainer := make([]*BoundKeyspaceIdQuery, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Queries = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteBatchKeyspaceIdsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExecuteBatchKeyspaceIdsResponse) CloneVT() *ExecuteBatchKeyspaceIdsResponse {
	if m == nil {
		return (*ExecuteBatchKeyspaceIdsResponse)(nil)
	}
	r := new(ExecuteBatchKeyspaceIdsResponse)
	r.Session = m.Session.CloneVT()
	if rhs := m.Error; rhs != nil {
		r.Error = rhs.CloneVT()
	}
	if rhs := m.Results; rhs != nil {
		tmpContainer := make([]*query.QueryResult, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Results = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExecuteBatchKeyspaceIdsResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteRequest) CloneVT() *StreamExecuteRequest {
	if m == nil {
		return (*StreamExecuteRequest)(nil)
	}
	r := new(StreamExecuteRequest)
	r.TabletType = m.TabletType
	r.KeyspaceShard = m.KeyspaceShard
	r.Session = m.Session.CloneVT()
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteResponse) CloneVT() *StreamExecuteResponse {
	if m == nil {
		return (*StreamExecuteResponse)(nil)
	}
	r := new(StreamExecuteResponse)
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteShardsRequest) CloneVT() *StreamExecuteShardsRequest {
	if m == nil {
		return (*StreamExecuteShardsRequest)(nil)
	}
	r := new(StreamExecuteShardsRequest)
	r.Keyspace = m.Keyspace
	r.TabletType = m.TabletType
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.Shards; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Shards = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteShardsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteShardsResponse) CloneVT() *StreamExecuteShardsResponse {
	if m == nil {
		return (*StreamExecuteShardsResponse)(nil)
	}
	r := new(StreamExecuteShardsResponse)
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteShardsResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteKeyspaceIdsRequest) CloneVT() *StreamExecuteKeyspaceIdsRequest {
	if m == nil {
		return (*StreamExecuteKeyspaceIdsRequest)(nil)
	}
	r := new(StreamExecuteKeyspaceIdsRequest)
	r.Keyspace = m.Keyspace
	r.TabletType = m.TabletType
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.KeyspaceIds; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.KeyspaceIds = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteKeyspaceIdsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteKeyspaceIdsResponse) CloneVT() *StreamExecuteKeyspaceIdsResponse {
	if m == nil {
		return (*StreamExecuteKeyspaceIdsResponse)(nil)
	}
	r := new(StreamExecuteKeyspaceIdsResponse)
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteKeyspaceIdsResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteKeyRangesRequest) CloneVT() *StreamExecuteKeyRangesRequest {
	if m == nil {
		return (*StreamExecuteKeyRangesRequest)(nil)
	}
	r := new(StreamExecuteKeyRangesRequest)
	r.Keyspace = m.Keyspace
	r.TabletType = m.TabletType
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.KeyRanges; rhs != nil {
		tmpContainer := make([]*topodata.KeyRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.KeyRanges = tmpContainer
	}
	if rhs := m.Options; rhs != nil {
		r.Options = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteKeyRangesRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StreamExecuteKeyRangesResponse) CloneVT() *StreamExecuteKeyRangesResponse {
	if m == nil {
		return (*StreamExecuteKeyRangesResponse)(nil)
	}
	r := new(StreamExecuteKeyRangesResponse)
	if rhs := m.Result; rhs != nil {
		r.Result = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StreamExecuteKeyRangesResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *BeginRequest) CloneVT() *BeginRequest {
	if m == nil {
		return (*BeginRequest)(nil)
	}
	r := new(BeginRequest)
	r.SingleDb = m.SingleDb
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *BeginRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *BeginResponse) CloneVT() *BeginResponse {
	if m == nil {
		return (*BeginResponse)(nil)
	}
	r := new(BeginResponse)
	r.Session = m.Session.CloneVT()
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *BeginResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *CommitRequest) CloneVT() *CommitRequest {
	if m == nil {
		return (*CommitRequest)(nil)
	}
	r := new(CommitRequest)
	r.Session = m.Session.CloneVT()
	r.Atomic = m.Atomic
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *CommitRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *CommitResponse) CloneVT() *CommitResponse {
	if m == nil {
		return (*CommitResponse)(nil)
	}
	r := new(CommitResponse)
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *CommitResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *RollbackRequest) CloneVT() *RollbackRequest {
	if m == nil {
		return (*RollbackRequest)(nil)
	}
	r := new(RollbackRequest)
	r.Session = m.Session.CloneVT()
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *RollbackRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *RollbackResponse) CloneVT() *RollbackResponse {
	if m == nil {
		return (*RollbackResponse)(nil)
	}
	r := new(RollbackResponse)
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *RollbackResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ResolveTransactionRequest) CloneVT() *ResolveTransactionRequest {
	if m == nil {
		return (*ResolveTransactionRequest)(nil)
	}
	r := new(ResolveTransactionRequest)
	r.Dtid = m.Dtid
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ResolveTransactionRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *MessageStreamRequest) CloneVT() *MessageStreamRequest {
	if m == nil {
		return (*MessageStreamRequest)(nil)
	}
	r := new(MessageStreamRequest)
	r.Keyspace = m.Keyspace
	r.Shard = m.Shard
	r.Name = m.Name
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.KeyRange; rhs != nil {
		r.KeyRange = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MessageStreamRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *MessageAckRequest) CloneVT() *MessageAckRequest {
	if m == nil {
		return (*MessageAckRequest)(nil)
	}
	r := new(MessageAckRequest)
	r.Keyspace = m.Keyspace
	r.Name = m.Name
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Ids; rhs != nil {
		tmpContainer := make([]*query.Value, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Ids = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MessageAckRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *IdKeyspaceId) CloneVT() *IdKeyspaceId {
	if m == nil {
		return (*IdKeyspaceId)(nil)
	}
	r := new(IdKeyspaceId)
	if rhs := m.Id; rhs != nil {
		r.Id = rhs.CloneVT()
	}
	if rhs := m.KeyspaceId; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.KeyspaceId = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *IdKeyspaceId) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *MessageAckKeyspaceIdsRequest) CloneVT() *MessageAckKeyspaceIdsRequest {
	if m == nil {
		return (*MessageAckKeyspaceIdsRequest)(nil)
	}
	r := new(MessageAckKeyspaceIdsRequest)
	r.Keyspace = m.Keyspace
	r.Name = m.Name
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.IdKeyspaceIds; rhs != nil {
		tmpContainer := make([]*IdKeyspaceId, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.IdKeyspaceIds = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MessageAckKeyspaceIdsRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ResolveTransactionResponse) CloneVT() *ResolveTransactionResponse {
	if m == nil {
		return (*ResolveTransactionResponse)(nil)
	}
	r := new(ResolveTransactionResponse)
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ResolveTransactionResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SplitQueryRequest) CloneVT() *SplitQueryRequest {
	if m == nil {
		return (*SplitQueryRequest)(nil)
	}
	r := new(SplitQueryRequest)
	r.Keyspace = m.Keyspace
	r.SplitCount = m.SplitCount
	r.NumRowsPerQueryPart = m.NumRowsPerQueryPart
	r.Algorithm = m.Algorithm
	r.UseSplitQueryV2 = m.UseSplitQueryV2
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if rhs := m.SplitColumn; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.SplitColumn = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SplitQueryRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SplitQueryResponse_KeyRangePart) CloneVT() *SplitQueryResponse_KeyRangePart {
	if m == nil {
		return (*SplitQueryResponse_KeyRangePart)(nil)
	}
	r := new(SplitQueryResponse_KeyRangePart)
	r.Keyspace = m.Keyspace
	if rhs := m.KeyRanges; rhs != nil {
		tmpContainer := make([]*topodata.KeyRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.KeyRanges = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SplitQueryResponse_KeyRangePart) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SplitQueryResponse_ShardPart) CloneVT() *SplitQueryResponse_ShardPart {
	if m == nil {
		return (*SplitQueryResponse_ShardPart)(nil)
	}
	r := new(SplitQueryResponse_ShardPart)
	r.Keyspace = m.Keyspace
	if rhs := m.Shards; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Shards = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SplitQueryResponse_ShardPart) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SplitQueryResponse_Part) CloneVT() *SplitQueryResponse_Part {
	if m == nil {
		return (*SplitQueryResponse_Part)(nil)
	}
	r := new(SplitQueryResponse_Part)
	r.KeyRangePart = m.KeyRangePart.CloneVT()
	r.ShardPart = m.ShardPart.CloneVT()
	r.Size = m.Size
	if rhs := m.Query; rhs != nil {
		r.Query = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SplitQueryResponse_Part) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SplitQueryResponse) CloneVT() *SplitQueryResponse {
	if m == nil {
		return (*SplitQueryResponse)(nil)
	}
	r := new(SplitQueryResponse)
	if rhs := m.Splits; rhs != nil {
		tmpContainer := make([]*SplitQueryResponse_Part, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Splits = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SplitQueryResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *GetSrvKeyspaceRequest) CloneVT() *GetSrvKeyspaceRequest {
	if m == nil {
		return (*GetSrvKeyspaceRequest)(nil)
	}
	r := new(GetSrvKeyspaceRequest)
	r.Keyspace = m.Keyspace
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetSrvKeyspaceRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *GetSrvKeyspaceResponse) CloneVT() *GetSrvKeyspaceResponse {
	if m == nil {
		return (*GetSrvKeyspaceResponse)(nil)
	}
	r := new(GetSrvKeyspaceResponse)
	if rhs := m.SrvKeyspace; rhs != nil {
		r.SrvKeyspace = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetSrvKeyspaceResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *VStreamRequest) CloneVT() *VStreamRequest {
	if m == nil {
		return (*VStreamRequest)(nil)
	}
	r := new(VStreamRequest)
	r.TabletType = m.TabletType
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.Vgtid; rhs != nil {
		r.Vgtid = rhs.CloneVT()
	}
	if rhs := m.Filter; rhs != nil {
		r.Filter = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *VStreamRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *VStreamResponse) CloneVT() *VStreamResponse {
	if m == nil {
		return (*VStreamResponse)(nil)
	}
	r := new(VStreamResponse)
	if rhs := m.Events; rhs != nil {
		tmpContainer := make([]*binlogdata.VEvent, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Events = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *VStreamResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *UpdateStreamRequest) CloneVT() *UpdateStreamRequest {
	if m == nil {
		return (*UpdateStreamRequest)(nil)
	}
	r := new(UpdateStreamRequest)
	r.Keyspace = m.Keyspace
	r.Shard = m.Shard
	r.TabletType = m.TabletType
	r.Timestamp = m.Timestamp
	if rhs := m.CallerId; rhs != nil {
		r.CallerId = rhs.CloneVT()
	}
	if rhs := m.KeyRange; rhs != nil {
		r.KeyRange = rhs.CloneVT()
	}
	if rhs := m.Event; rhs != nil {
		r.Event = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UpdateStreamRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *UpdateStreamResponse) CloneVT() *UpdateStreamResponse {
	if m == nil {
		return (*UpdateStreamResponse)(nil)
	}
	r := new(UpdateStreamResponse)
	r.ResumeTimestamp = m.ResumeTimestamp
	if rhs := m.Event; rhs != nil {
		r.Event = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UpdateStreamResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *Session_ShardSession) EqualVT(that *Session_ShardSession) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Target.EqualVT(that.Target) {
		return false
	}
	if this.TransactionId != that.TransactionId {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Session_ShardSession) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Session_ShardSession)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Session) EqualVT(that *Session) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.InTransaction != that.InTransaction {
		return false
	}
	if len(this.ShardSessions) != len(that.ShardSessions) {
		return false
	}
	for i, vx := range this.ShardSessions {
		vy := that.ShardSessions[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Session_ShardSession{}
			}
			if q == nil {
				q = &Session_ShardSession{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.SingleDb != that.SingleDb {
		return false
	}
	if this.Autocommit != that.Autocommit {
		return false
	}
	if this.TargetString != that.TargetString {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	if this.TransactionMode != that.TransactionMode {
		return false
	}
	if len(this.Warnings) != len(that.Warnings) {
		return false
	}
	for i, vx := range this.Warnings {
		vy := that.Warnings[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &query.QueryWarning{}
			}
			if q == nil {
				q = &query.QueryWarning{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.PreSessions) != len(that.PreSessions) {
		return false
	}
	for i, vx := range this.PreSessions {
		vy := that.PreSessions[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Session_ShardSession{}
			}
			if q == nil {
				q = &Session_ShardSession{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.PostSessions) != len(that.PostSessions) {
		return false
	}
	for i, vx := range this.PostSessions {
		vy := that.PostSessions[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Session_ShardSession{}
			}
			if q == nil {
				q = &Session_ShardSession{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Session) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Session)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteRequest) EqualVT(that *ExecuteRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.NotInTransaction != that.NotInTransaction {
		return false
	}
	if this.KeyspaceShard != that.KeyspaceShard {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteResponse) EqualVT(that *ExecuteResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteShardsRequest) EqualVT(that *ExecuteShardsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.Shards) != len(that.Shards) {
		return false
	}
	for i, vx := range this.Shards {
		vy := that.Shards[i]
		if vx != vy {
			return false
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.NotInTransaction != that.NotInTransaction {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteShardsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteShardsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteShardsResponse) EqualVT(that *ExecuteShardsResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteShardsResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteShardsResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteKeyspaceIdsRequest) EqualVT(that *ExecuteKeyspaceIdsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.KeyspaceIds) != len(that.KeyspaceIds) {
		return false
	}
	for i, vx := range this.KeyspaceIds {
		vy := that.KeyspaceIds[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.NotInTransaction != that.NotInTransaction {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteKeyspaceIdsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteKeyspaceIdsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteKeyspaceIdsResponse) EqualVT(that *ExecuteKeyspaceIdsResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteKeyspaceIdsResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteKeyspaceIdsResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteKeyRangesRequest) EqualVT(that *ExecuteKeyRangesRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.KeyRanges) != len(that.KeyRanges) {
		return false
	}
	for i, vx := range this.KeyRanges {
		vy := that.KeyRanges[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &topodata.KeyRange{}
			}
			if q == nil {
				q = &topodata.KeyRange{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.NotInTransaction != that.NotInTransaction {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteKeyRangesRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteKeyRangesRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteKeyRangesResponse) EqualVT(that *ExecuteKeyRangesResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteKeyRangesResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteKeyRangesResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteEntityIdsRequest_EntityId) EqualVT(that *ExecuteEntityIdsRequest_EntityId) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Type != that.Type {
		return false
	}
	if string(this.Value) != string(that.Value) {
		return false
	}
	if string(this.KeyspaceId) != string(that.KeyspaceId) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteEntityIdsRequest_EntityId) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteEntityIdsRequest_EntityId)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteEntityIdsRequest) EqualVT(that *ExecuteEntityIdsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if this.EntityColumnName != that.EntityColumnName {
		return false
	}
	if len(this.EntityKeyspaceIds) != len(that.EntityKeyspaceIds) {
		return false
	}
	for i, vx := range this.EntityKeyspaceIds {
		vy := that.EntityKeyspaceIds[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ExecuteEntityIdsRequest_EntityId{}
			}
			if q == nil {
				q = &ExecuteEntityIdsRequest_EntityId{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.NotInTransaction != that.NotInTransaction {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteEntityIdsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteEntityIdsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteEntityIdsResponse) EqualVT(that *ExecuteEntityIdsResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteEntityIdsResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteEntityIdsResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteBatchRequest) EqualVT(that *ExecuteBatchRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if len(this.Queries) != len(that.Queries) {
		return false
	}
	for i, vx := range this.Queries {
		vy := that.Queries[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &query.BoundQuery{}
			}
			if q == nil {
				q = &query.BoundQuery{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.AsTransaction != that.AsTransaction {
		return false
	}
	if this.KeyspaceShard != that.KeyspaceShard {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteBatchRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteBatchRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteBatchResponse) EqualVT(that *ExecuteBatchResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if len(this.Results) != len(that.Results) {
		return false
	}
	for i, vx := range this.Results {
		vy := that.Results[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &query.ResultWithError{}
			}
			if q == nil {
				q = &query.ResultWithError{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteBatchResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteBatchResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *BoundShardQuery) EqualVT(that *BoundShardQuery) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.Shards) != len(that.Shards) {
		return false
	}
	for i, vx := range this.Shards {
		vy := that.Shards[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *BoundShardQuery) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*BoundShardQuery)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteBatchShardsRequest) EqualVT(that *ExecuteBatchShardsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if len(this.Queries) != len(that.Queries) {
		return false
	}
	for i, vx := range this.Queries {
		vy := that.Queries[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &BoundShardQuery{}
			}
			if q == nil {
				q = &BoundShardQuery{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.AsTransaction != that.AsTransaction {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteBatchShardsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteBatchShardsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteBatchShardsResponse) EqualVT(that *ExecuteBatchShardsResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if len(this.Results) != len(that.Results) {
		return false
	}
	for i, vx := range this.Results {
		vy := that.Results[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &query.QueryResult{}
			}
			if q == nil {
				q = &query.QueryResult{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteBatchShardsResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteBatchShardsResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *BoundKeyspaceIdQuery) EqualVT(that *BoundKeyspaceIdQuery) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.KeyspaceIds) != len(that.KeyspaceIds) {
		return false
	}
	for i, vx := range this.KeyspaceIds {
		vy := that.KeyspaceIds[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *BoundKeyspaceIdQuery) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*BoundKeyspaceIdQuery)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteBatchKeyspaceIdsRequest) EqualVT(that *ExecuteBatchKeyspaceIdsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if len(this.Queries) != len(that.Queries) {
		return false
	}
	for i, vx := range this.Queries {
		vy := that.Queries[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &BoundKeyspaceIdQuery{}
			}
			if q == nil {
				q = &BoundKeyspaceIdQuery{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.AsTransaction != that.AsTransaction {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteBatchKeyspaceIdsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteBatchKeyspaceIdsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExecuteBatchKeyspaceIdsResponse) EqualVT(that *ExecuteBatchKeyspaceIdsResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Error.EqualVT(that.Error) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if len(this.Results) != len(that.Results) {
		return false
	}
	for i, vx := range this.Results {
		vy := that.Results[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &query.QueryResult{}
			}
			if q == nil {
				q = &query.QueryResult{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExecuteBatchKeyspaceIdsResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExecuteBatchKeyspaceIdsResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteRequest) EqualVT(that *StreamExecuteRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.KeyspaceShard != that.KeyspaceShard {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteResponse) EqualVT(that *StreamExecuteResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteShardsRequest) EqualVT(that *StreamExecuteShardsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.Shards) != len(that.Shards) {
		return false
	}
	for i, vx := range this.Shards {
		vy := that.Shards[i]
		if vx != vy {
			return false
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteShardsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteShardsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteShardsResponse) EqualVT(that *StreamExecuteShardsResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteShardsResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteShardsResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteKeyspaceIdsRequest) EqualVT(that *StreamExecuteKeyspaceIdsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.KeyspaceIds) != len(that.KeyspaceIds) {
		return false
	}
	for i, vx := range this.KeyspaceIds {
		vy := that.KeyspaceIds[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteKeyspaceIdsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteKeyspaceIdsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteKeyspaceIdsResponse) EqualVT(that *StreamExecuteKeyspaceIdsResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteKeyspaceIdsResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteKeyspaceIdsResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteKeyRangesRequest) EqualVT(that *StreamExecuteKeyRangesRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.KeyRanges) != len(that.KeyRanges) {
		return false
	}
	for i, vx := range this.KeyRanges {
		vy := that.KeyRanges[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &topodata.KeyRange{}
			}
			if q == nil {
				q = &topodata.KeyRange{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteKeyRangesRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteKeyRangesRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StreamExecuteKeyRangesResponse) EqualVT(that *StreamExecuteKeyRangesResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Result.EqualVT(that.Result) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StreamExecuteKeyRangesResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StreamExecuteKeyRangesResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *BeginRequest) EqualVT(that *BeginRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.SingleDb != that.SingleDb {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *BeginRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*BeginRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *BeginResponse) EqualVT(that *BeginResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *BeginResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*BeginResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *CommitRequest) EqualVT(that *CommitRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	if this.Atomic != that.Atomic {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *CommitRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*CommitRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *CommitResponse) EqualVT(that *CommitResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *CommitResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*CommitResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *RollbackRequest) EqualVT(that *RollbackRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if !this.Session.EqualVT(that.Session) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *RollbackRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*RollbackRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *RollbackResponse) EqualVT(that *RollbackResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *RollbackResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*RollbackResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ResolveTransactionRequest) EqualVT(that *ResolveTransactionRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.Dtid != that.Dtid {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ResolveTransactionRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ResolveTransactionRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MessageStreamRequest) EqualVT(that *MessageStreamRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if this.Shard != that.Shard {
		return false
	}
	if !this.KeyRange.EqualVT(that.KeyRange) {
		return false
	}
	if this.Name != that.Name {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MessageStreamRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*MessageStreamRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MessageAckRequest) EqualVT(that *MessageAckRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if this.Name != that.Name {
		return false
	}
	if len(this.Ids) != len(that.Ids) {
		return false
	}
	for i, vx := range this.Ids {
		vy := that.Ids[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &query.Value{}
			}
			if q == nil {
				q = &query.Value{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MessageAckRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*MessageAckRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *IdKeyspaceId) EqualVT(that *IdKeyspaceId) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Id.EqualVT(that.Id) {
		return false
	}
	if string(this.KeyspaceId) != string(that.KeyspaceId) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *IdKeyspaceId) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*IdKeyspaceId)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MessageAckKeyspaceIdsRequest) EqualVT(that *MessageAckKeyspaceIdsRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if this.Name != that.Name {
		return false
	}
	if len(this.IdKeyspaceIds) != len(that.IdKeyspaceIds) {
		return false
	}
	for i, vx := range this.IdKeyspaceIds {
		vy := that.IdKeyspaceIds[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &IdKeyspaceId{}
			}
			if q == nil {
				q = &IdKeyspaceId{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MessageAckKeyspaceIdsRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*MessageAckKeyspaceIdsRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ResolveTransactionResponse) EqualVT(that *ResolveTransactionResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ResolveTransactionResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ResolveTransactionResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SplitQueryRequest) EqualVT(that *SplitQueryRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if len(this.SplitColumn) != len(that.SplitColumn) {
		return false
	}
	for i, vx := range this.SplitColumn {
		vy := that.SplitColumn[i]
		if vx != vy {
			return false
		}
	}
	if this.SplitCount != that.SplitCount {
		return false
	}
	if this.NumRowsPerQueryPart != that.NumRowsPerQueryPart {
		return false
	}
	if this.Algorithm != that.Algorithm {
		return false
	}
	if this.UseSplitQueryV2 != that.UseSplitQueryV2 {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SplitQueryRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SplitQueryRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SplitQueryResponse_KeyRangePart) EqualVT(that *SplitQueryResponse_KeyRangePart) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.KeyRanges) != len(that.KeyRanges) {
		return false
	}
	for i, vx := range this.KeyRanges {
		vy := that.KeyRanges[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &topodata.KeyRange{}
			}
			if q == nil {
				q = &topodata.KeyRange{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SplitQueryResponse_KeyRangePart) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SplitQueryResponse_KeyRangePart)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SplitQueryResponse_ShardPart) EqualVT(that *SplitQueryResponse_ShardPart) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if len(this.Shards) != len(that.Shards) {
		return false
	}
	for i, vx := range this.Shards {
		vy := that.Shards[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SplitQueryResponse_ShardPart) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SplitQueryResponse_ShardPart)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SplitQueryResponse_Part) EqualVT(that *SplitQueryResponse_Part) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Query.EqualVT(that.Query) {
		return false
	}
	if !this.KeyRangePart.EqualVT(that.KeyRangePart) {
		return false
	}
	if !this.ShardPart.EqualVT(that.ShardPart) {
		return false
	}
	if this.Size != that.Size {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SplitQueryResponse_Part) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SplitQueryResponse_Part)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SplitQueryResponse) EqualVT(that *SplitQueryResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Splits) != len(that.Splits) {
		return false
	}
	for i, vx := range this.Splits {
		vy := that.Splits[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &SplitQueryResponse_Part{}
			}
			if q == nil {
				q = &SplitQueryResponse_Part{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SplitQueryResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SplitQueryResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *GetSrvKeyspaceRequest) EqualVT(that *GetSrvKeyspaceRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetSrvKeyspaceRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*GetSrvKeyspaceRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *GetSrvKeyspaceResponse) EqualVT(that *GetSrvKeyspaceResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.SrvKeyspace.EqualVT(that.SrvKeyspace) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetSrvKeyspaceResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*GetSrvKeyspaceResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *VStreamRequest) EqualVT(that *VStreamRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if !this.Vgtid.EqualVT(that.Vgtid) {
		return false
	}
	if !this.Filter.EqualVT(that.Filter) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *VStreamRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*VStreamRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *VStreamResponse) EqualVT(that *VStreamResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Events) != len(that.Events) {
		return false
	}
	for i, vx := range this.Events {
		vy := that.Events[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &binlogdata.VEvent{}
			}
			if q == nil {
				q = &binlogdata.VEvent{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *VStreamResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*VStreamResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UpdateStreamRequest) EqualVT(that *UpdateStreamRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.CallerId.EqualVT(that.CallerId) {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if this.Shard != that.Shard {
		return false
	}
	if !this.KeyRange.EqualVT(that.KeyRange) {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.Timestamp != that.Timestamp {
		return false
	}
	if !this.Event.EqualVT(that.Event) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UpdateStreamRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*UpdateStreamRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UpdateStreamResponse) EqualVT(that *UpdateStreamResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Event.EqualVT(that.Event) {
		return false
	}
	if this.ResumeTimestamp != that.ResumeTimestamp {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UpdateStreamResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*UpdateStreamResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// MarshalProtoJSON marshals the TransactionMode to JSON.
func (x TransactionMode) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), TransactionMode_name)
}

// MarshalText marshals the TransactionMode to text.
func (x TransactionMode) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), TransactionMode_name)), nil
}

// MarshalJSON marshals the TransactionMode to JSON.
func (x TransactionMode) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the TransactionMode from JSON.
func (x *TransactionMode) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(TransactionMode_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read TransactionMode enum: %v", err)
		return
	}
	*x = TransactionMode(v)
}

// UnmarshalText unmarshals the TransactionMode from text.
func (x *TransactionMode) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), TransactionMode_value)
	if err != nil {
		return err
	}
	*x = TransactionMode(i)
	return nil
}

// UnmarshalJSON unmarshals the TransactionMode from JSON.
func (x *TransactionMode) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the CommitOrder to JSON.
func (x CommitOrder) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), CommitOrder_name)
}

// MarshalText marshals the CommitOrder to text.
func (x CommitOrder) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), CommitOrder_name)), nil
}

// MarshalJSON marshals the CommitOrder to JSON.
func (x CommitOrder) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the CommitOrder from JSON.
func (x *CommitOrder) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(CommitOrder_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read CommitOrder enum: %v", err)
		return
	}
	*x = CommitOrder(v)
}

// UnmarshalText unmarshals the CommitOrder from text.
func (x *CommitOrder) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), CommitOrder_value)
	if err != nil {
		return err
	}
	*x = CommitOrder(i)
	return nil
}

// UnmarshalJSON unmarshals the CommitOrder from JSON.
func (x *CommitOrder) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Session_ShardSession message to JSON.
func (x *Session_ShardSession) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Target != nil || s.HasField("target") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("target")
		x.Target.MarshalProtoJSON(s.WithField("target"))
	}
	if x.TransactionId != 0 || s.HasField("transactionId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("transactionId")
		s.WriteInt64(x.TransactionId)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Session_ShardSession to JSON.
func (x *Session_ShardSession) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Session_ShardSession message from JSON.
func (x *Session_ShardSession) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "target":
			if s.ReadNil() {
				x.Target = nil
				return
			}
			x.Target = &query.Target{}
			x.Target.UnmarshalProtoJSON(s.WithField("target", true))
		case "transaction_id", "transactionId":
			s.AddField("transaction_id")
			x.TransactionId = s.ReadInt64()
		}
	})
}

// UnmarshalJSON unmarshals the Session_ShardSession from JSON.
func (x *Session_ShardSession) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Session message to JSON.
func (x *Session) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.InTransaction || s.HasField("inTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("inTransaction")
		s.WriteBool(x.InTransaction)
	}
	if len(x.ShardSessions) > 0 || s.HasField("shardSessions") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardSessions")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.ShardSessions {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("shardSessions"))
		}
		s.WriteArrayEnd()
	}
	if x.SingleDb || s.HasField("singleDb") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("singleDb")
		s.WriteBool(x.SingleDb)
	}
	if x.Autocommit || s.HasField("autocommit") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("autocommit")
		s.WriteBool(x.Autocommit)
	}
	if x.TargetString != "" || s.HasField("targetString") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("targetString")
		s.WriteString(x.TargetString)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	if x.TransactionMode != 0 || s.HasField("transactionMode") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("transactionMode")
		x.TransactionMode.MarshalProtoJSON(s)
	}
	if len(x.Warnings) > 0 || s.HasField("warnings") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("warnings")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Warnings {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("warnings"))
		}
		s.WriteArrayEnd()
	}
	if len(x.PreSessions) > 0 || s.HasField("preSessions") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("preSessions")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.PreSessions {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("preSessions"))
		}
		s.WriteArrayEnd()
	}
	if len(x.PostSessions) > 0 || s.HasField("postSessions") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("postSessions")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.PostSessions {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("postSessions"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Session to JSON.
func (x *Session) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Session message from JSON.
func (x *Session) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "in_transaction", "inTransaction":
			s.AddField("in_transaction")
			x.InTransaction = s.ReadBool()
		case "shard_sessions", "shardSessions":
			s.AddField("shard_sessions")
			if s.ReadNil() {
				x.ShardSessions = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.ShardSessions = append(x.ShardSessions, nil)
					return
				}
				v := &Session_ShardSession{}
				v.UnmarshalProtoJSON(s.WithField("shard_sessions", false))
				if s.Err() != nil {
					return
				}
				x.ShardSessions = append(x.ShardSessions, v)
			})
		case "single_db", "singleDb":
			s.AddField("single_db")
			x.SingleDb = s.ReadBool()
		case "autocommit":
			s.AddField("autocommit")
			x.Autocommit = s.ReadBool()
		case "target_string", "targetString":
			s.AddField("target_string")
			x.TargetString = s.ReadString()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		case "transaction_mode", "transactionMode":
			s.AddField("transaction_mode")
			x.TransactionMode.UnmarshalProtoJSON(s)
		case "warnings":
			s.AddField("warnings")
			if s.ReadNil() {
				x.Warnings = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Warnings = append(x.Warnings, nil)
					return
				}
				v := &query.QueryWarning{}
				v.UnmarshalProtoJSON(s.WithField("warnings", false))
				if s.Err() != nil {
					return
				}
				x.Warnings = append(x.Warnings, v)
			})
		case "pre_sessions", "preSessions":
			s.AddField("pre_sessions")
			if s.ReadNil() {
				x.PreSessions = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.PreSessions = append(x.PreSessions, nil)
					return
				}
				v := &Session_ShardSession{}
				v.UnmarshalProtoJSON(s.WithField("pre_sessions", false))
				if s.Err() != nil {
					return
				}
				x.PreSessions = append(x.PreSessions, v)
			})
		case "post_sessions", "postSessions":
			s.AddField("post_sessions")
			if s.ReadNil() {
				x.PostSessions = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.PostSessions = append(x.PostSessions, nil)
					return
				}
				v := &Session_ShardSession{}
				v.UnmarshalProtoJSON(s.WithField("post_sessions", false))
				if s.Err() != nil {
					return
				}
				x.PostSessions = append(x.PostSessions, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the Session from JSON.
func (x *Session) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteRequest message to JSON.
func (x *ExecuteRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.NotInTransaction || s.HasField("notInTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("notInTransaction")
		s.WriteBool(x.NotInTransaction)
	}
	if x.KeyspaceShard != "" || s.HasField("keyspaceShard") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceShard")
		s.WriteString(x.KeyspaceShard)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteRequest to JSON.
func (x *ExecuteRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteRequest message from JSON.
func (x *ExecuteRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "not_in_transaction", "notInTransaction":
			s.AddField("not_in_transaction")
			x.NotInTransaction = s.ReadBool()
		case "keyspace_shard", "keyspaceShard":
			s.AddField("keyspace_shard")
			x.KeyspaceShard = s.ReadString()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteRequest from JSON.
func (x *ExecuteRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteResponse message to JSON.
func (x *ExecuteResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteResponse to JSON.
func (x *ExecuteResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteResponse message from JSON.
func (x *ExecuteResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteResponse from JSON.
func (x *ExecuteResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteShardsRequest message to JSON.
func (x *ExecuteShardsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.Shards) > 0 || s.HasField("shards") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shards")
		s.WriteStringArray(x.Shards)
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.NotInTransaction || s.HasField("notInTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("notInTransaction")
		s.WriteBool(x.NotInTransaction)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteShardsRequest to JSON.
func (x *ExecuteShardsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteShardsRequest message from JSON.
func (x *ExecuteShardsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shards":
			s.AddField("shards")
			if s.ReadNil() {
				x.Shards = nil
				return
			}
			x.Shards = s.ReadStringArray()
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "not_in_transaction", "notInTransaction":
			s.AddField("not_in_transaction")
			x.NotInTransaction = s.ReadBool()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteShardsRequest from JSON.
func (x *ExecuteShardsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteShardsResponse message to JSON.
func (x *ExecuteShardsResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteShardsResponse to JSON.
func (x *ExecuteShardsResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteShardsResponse message from JSON.
func (x *ExecuteShardsResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteShardsResponse from JSON.
func (x *ExecuteShardsResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteKeyspaceIdsRequest message to JSON.
func (x *ExecuteKeyspaceIdsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.KeyspaceIds) > 0 || s.HasField("keyspaceIds") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceIds")
		s.WriteBytesArray(x.KeyspaceIds)
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.NotInTransaction || s.HasField("notInTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("notInTransaction")
		s.WriteBool(x.NotInTransaction)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteKeyspaceIdsRequest to JSON.
func (x *ExecuteKeyspaceIdsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteKeyspaceIdsRequest message from JSON.
func (x *ExecuteKeyspaceIdsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "keyspace_ids", "keyspaceIds":
			s.AddField("keyspace_ids")
			if s.ReadNil() {
				x.KeyspaceIds = nil
				return
			}
			x.KeyspaceIds = s.ReadBytesArray()
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "not_in_transaction", "notInTransaction":
			s.AddField("not_in_transaction")
			x.NotInTransaction = s.ReadBool()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteKeyspaceIdsRequest from JSON.
func (x *ExecuteKeyspaceIdsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteKeyspaceIdsResponse message to JSON.
func (x *ExecuteKeyspaceIdsResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteKeyspaceIdsResponse to JSON.
func (x *ExecuteKeyspaceIdsResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteKeyspaceIdsResponse message from JSON.
func (x *ExecuteKeyspaceIdsResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteKeyspaceIdsResponse from JSON.
func (x *ExecuteKeyspaceIdsResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteKeyRangesRequest message to JSON.
func (x *ExecuteKeyRangesRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.KeyRanges) > 0 || s.HasField("keyRanges") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRanges")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.KeyRanges {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("keyRanges"))
		}
		s.WriteArrayEnd()
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.NotInTransaction || s.HasField("notInTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("notInTransaction")
		s.WriteBool(x.NotInTransaction)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteKeyRangesRequest to JSON.
func (x *ExecuteKeyRangesRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteKeyRangesRequest message from JSON.
func (x *ExecuteKeyRangesRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "key_ranges", "keyRanges":
			s.AddField("key_ranges")
			if s.ReadNil() {
				x.KeyRanges = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.KeyRanges = append(x.KeyRanges, nil)
					return
				}
				v := &topodata.KeyRange{}
				v.UnmarshalProtoJSON(s.WithField("key_ranges", false))
				if s.Err() != nil {
					return
				}
				x.KeyRanges = append(x.KeyRanges, v)
			})
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "not_in_transaction", "notInTransaction":
			s.AddField("not_in_transaction")
			x.NotInTransaction = s.ReadBool()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteKeyRangesRequest from JSON.
func (x *ExecuteKeyRangesRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteKeyRangesResponse message to JSON.
func (x *ExecuteKeyRangesResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteKeyRangesResponse to JSON.
func (x *ExecuteKeyRangesResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteKeyRangesResponse message from JSON.
func (x *ExecuteKeyRangesResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteKeyRangesResponse from JSON.
func (x *ExecuteKeyRangesResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteEntityIdsRequest_EntityId message to JSON.
func (x *ExecuteEntityIdsRequest_EntityId) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Type != 0 || s.HasField("type") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("type")
		x.Type.MarshalProtoJSON(s)
	}
	if len(x.Value) > 0 || s.HasField("value") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("value")
		s.WriteBytes(x.Value)
	}
	if len(x.KeyspaceId) > 0 || s.HasField("keyspaceId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceId")
		s.WriteBytes(x.KeyspaceId)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteEntityIdsRequest_EntityId to JSON.
func (x *ExecuteEntityIdsRequest_EntityId) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteEntityIdsRequest_EntityId message from JSON.
func (x *ExecuteEntityIdsRequest_EntityId) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "type":
			s.AddField("type")
			x.Type.UnmarshalProtoJSON(s)
		case "value":
			s.AddField("value")
			x.Value = s.ReadBytes()
		case "keyspace_id", "keyspaceId":
			s.AddField("keyspace_id")
			x.KeyspaceId = s.ReadBytes()
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteEntityIdsRequest_EntityId from JSON.
func (x *ExecuteEntityIdsRequest_EntityId) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteEntityIdsRequest message to JSON.
func (x *ExecuteEntityIdsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.EntityColumnName != "" || s.HasField("entityColumnName") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("entityColumnName")
		s.WriteString(x.EntityColumnName)
	}
	if len(x.EntityKeyspaceIds) > 0 || s.HasField("entityKeyspaceIds") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("entityKeyspaceIds")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.EntityKeyspaceIds {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("entityKeyspaceIds"))
		}
		s.WriteArrayEnd()
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.NotInTransaction || s.HasField("notInTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("notInTransaction")
		s.WriteBool(x.NotInTransaction)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteEntityIdsRequest to JSON.
func (x *ExecuteEntityIdsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteEntityIdsRequest message from JSON.
func (x *ExecuteEntityIdsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "entity_column_name", "entityColumnName":
			s.AddField("entity_column_name")
			x.EntityColumnName = s.ReadString()
		case "entity_keyspace_ids", "entityKeyspaceIds":
			s.AddField("entity_keyspace_ids")
			if s.ReadNil() {
				x.EntityKeyspaceIds = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.EntityKeyspaceIds = append(x.EntityKeyspaceIds, nil)
					return
				}
				v := &ExecuteEntityIdsRequest_EntityId{}
				v.UnmarshalProtoJSON(s.WithField("entity_keyspace_ids", false))
				if s.Err() != nil {
					return
				}
				x.EntityKeyspaceIds = append(x.EntityKeyspaceIds, v)
			})
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "not_in_transaction", "notInTransaction":
			s.AddField("not_in_transaction")
			x.NotInTransaction = s.ReadBool()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteEntityIdsRequest from JSON.
func (x *ExecuteEntityIdsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteEntityIdsResponse message to JSON.
func (x *ExecuteEntityIdsResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteEntityIdsResponse to JSON.
func (x *ExecuteEntityIdsResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteEntityIdsResponse message from JSON.
func (x *ExecuteEntityIdsResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteEntityIdsResponse from JSON.
func (x *ExecuteEntityIdsResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteBatchRequest message to JSON.
func (x *ExecuteBatchRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if len(x.Queries) > 0 || s.HasField("queries") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("queries")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Queries {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("queries"))
		}
		s.WriteArrayEnd()
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.AsTransaction || s.HasField("asTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("asTransaction")
		s.WriteBool(x.AsTransaction)
	}
	if x.KeyspaceShard != "" || s.HasField("keyspaceShard") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceShard")
		s.WriteString(x.KeyspaceShard)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteBatchRequest to JSON.
func (x *ExecuteBatchRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteBatchRequest message from JSON.
func (x *ExecuteBatchRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "queries":
			s.AddField("queries")
			if s.ReadNil() {
				x.Queries = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Queries = append(x.Queries, nil)
					return
				}
				v := &query.BoundQuery{}
				v.UnmarshalProtoJSON(s.WithField("queries", false))
				if s.Err() != nil {
					return
				}
				x.Queries = append(x.Queries, v)
			})
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "as_transaction", "asTransaction":
			s.AddField("as_transaction")
			x.AsTransaction = s.ReadBool()
		case "keyspace_shard", "keyspaceShard":
			s.AddField("keyspace_shard")
			x.KeyspaceShard = s.ReadString()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteBatchRequest from JSON.
func (x *ExecuteBatchRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteBatchResponse message to JSON.
func (x *ExecuteBatchResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if len(x.Results) > 0 || s.HasField("results") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("results")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Results {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("results"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteBatchResponse to JSON.
func (x *ExecuteBatchResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteBatchResponse message from JSON.
func (x *ExecuteBatchResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "results":
			s.AddField("results")
			if s.ReadNil() {
				x.Results = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Results = append(x.Results, nil)
					return
				}
				v := &query.ResultWithError{}
				v.UnmarshalProtoJSON(s.WithField("results", false))
				if s.Err() != nil {
					return
				}
				x.Results = append(x.Results, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteBatchResponse from JSON.
func (x *ExecuteBatchResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the BoundShardQuery message to JSON.
func (x *BoundShardQuery) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.Shards) > 0 || s.HasField("shards") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shards")
		s.WriteStringArray(x.Shards)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the BoundShardQuery to JSON.
func (x *BoundShardQuery) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the BoundShardQuery message from JSON.
func (x *BoundShardQuery) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shards":
			s.AddField("shards")
			if s.ReadNil() {
				x.Shards = nil
				return
			}
			x.Shards = s.ReadStringArray()
		}
	})
}

// UnmarshalJSON unmarshals the BoundShardQuery from JSON.
func (x *BoundShardQuery) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteBatchShardsRequest message to JSON.
func (x *ExecuteBatchShardsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if len(x.Queries) > 0 || s.HasField("queries") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("queries")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Queries {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("queries"))
		}
		s.WriteArrayEnd()
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.AsTransaction || s.HasField("asTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("asTransaction")
		s.WriteBool(x.AsTransaction)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteBatchShardsRequest to JSON.
func (x *ExecuteBatchShardsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteBatchShardsRequest message from JSON.
func (x *ExecuteBatchShardsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "queries":
			s.AddField("queries")
			if s.ReadNil() {
				x.Queries = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Queries = append(x.Queries, nil)
					return
				}
				v := &BoundShardQuery{}
				v.UnmarshalProtoJSON(s.WithField("queries", false))
				if s.Err() != nil {
					return
				}
				x.Queries = append(x.Queries, v)
			})
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "as_transaction", "asTransaction":
			s.AddField("as_transaction")
			x.AsTransaction = s.ReadBool()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteBatchShardsRequest from JSON.
func (x *ExecuteBatchShardsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteBatchShardsResponse message to JSON.
func (x *ExecuteBatchShardsResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if len(x.Results) > 0 || s.HasField("results") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("results")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Results {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("results"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteBatchShardsResponse to JSON.
func (x *ExecuteBatchShardsResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteBatchShardsResponse message from JSON.
func (x *ExecuteBatchShardsResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "results":
			s.AddField("results")
			if s.ReadNil() {
				x.Results = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Results = append(x.Results, nil)
					return
				}
				v := &query.QueryResult{}
				v.UnmarshalProtoJSON(s.WithField("results", false))
				if s.Err() != nil {
					return
				}
				x.Results = append(x.Results, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteBatchShardsResponse from JSON.
func (x *ExecuteBatchShardsResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the BoundKeyspaceIdQuery message to JSON.
func (x *BoundKeyspaceIdQuery) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.KeyspaceIds) > 0 || s.HasField("keyspaceIds") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceIds")
		s.WriteBytesArray(x.KeyspaceIds)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the BoundKeyspaceIdQuery to JSON.
func (x *BoundKeyspaceIdQuery) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the BoundKeyspaceIdQuery message from JSON.
func (x *BoundKeyspaceIdQuery) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "keyspace_ids", "keyspaceIds":
			s.AddField("keyspace_ids")
			if s.ReadNil() {
				x.KeyspaceIds = nil
				return
			}
			x.KeyspaceIds = s.ReadBytesArray()
		}
	})
}

// UnmarshalJSON unmarshals the BoundKeyspaceIdQuery from JSON.
func (x *BoundKeyspaceIdQuery) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteBatchKeyspaceIdsRequest message to JSON.
func (x *ExecuteBatchKeyspaceIdsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if len(x.Queries) > 0 || s.HasField("queries") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("queries")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Queries {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("queries"))
		}
		s.WriteArrayEnd()
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.AsTransaction || s.HasField("asTransaction") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("asTransaction")
		s.WriteBool(x.AsTransaction)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteBatchKeyspaceIdsRequest to JSON.
func (x *ExecuteBatchKeyspaceIdsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteBatchKeyspaceIdsRequest message from JSON.
func (x *ExecuteBatchKeyspaceIdsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "queries":
			s.AddField("queries")
			if s.ReadNil() {
				x.Queries = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Queries = append(x.Queries, nil)
					return
				}
				v := &BoundKeyspaceIdQuery{}
				v.UnmarshalProtoJSON(s.WithField("queries", false))
				if s.Err() != nil {
					return
				}
				x.Queries = append(x.Queries, v)
			})
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "as_transaction", "asTransaction":
			s.AddField("as_transaction")
			x.AsTransaction = s.ReadBool()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteBatchKeyspaceIdsRequest from JSON.
func (x *ExecuteBatchKeyspaceIdsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ExecuteBatchKeyspaceIdsResponse message to JSON.
func (x *ExecuteBatchKeyspaceIdsResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Error != nil || s.HasField("error") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("error")
		x.Error.MarshalProtoJSON(s.WithField("error"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if len(x.Results) > 0 || s.HasField("results") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("results")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Results {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("results"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ExecuteBatchKeyspaceIdsResponse to JSON.
func (x *ExecuteBatchKeyspaceIdsResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ExecuteBatchKeyspaceIdsResponse message from JSON.
func (x *ExecuteBatchKeyspaceIdsResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "error":
			if s.ReadNil() {
				x.Error = nil
				return
			}
			x.Error = &vtrpc.RPCError{}
			x.Error.UnmarshalProtoJSON(s.WithField("error", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "results":
			s.AddField("results")
			if s.ReadNil() {
				x.Results = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Results = append(x.Results, nil)
					return
				}
				v := &query.QueryResult{}
				v.UnmarshalProtoJSON(s.WithField("results", false))
				if s.Err() != nil {
					return
				}
				x.Results = append(x.Results, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the ExecuteBatchKeyspaceIdsResponse from JSON.
func (x *ExecuteBatchKeyspaceIdsResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteRequest message to JSON.
func (x *StreamExecuteRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.KeyspaceShard != "" || s.HasField("keyspaceShard") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceShard")
		s.WriteString(x.KeyspaceShard)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteRequest to JSON.
func (x *StreamExecuteRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteRequest message from JSON.
func (x *StreamExecuteRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "keyspace_shard", "keyspaceShard":
			s.AddField("keyspace_shard")
			x.KeyspaceShard = s.ReadString()
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteRequest from JSON.
func (x *StreamExecuteRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteResponse message to JSON.
func (x *StreamExecuteResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteResponse to JSON.
func (x *StreamExecuteResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteResponse message from JSON.
func (x *StreamExecuteResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteResponse from JSON.
func (x *StreamExecuteResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteShardsRequest message to JSON.
func (x *StreamExecuteShardsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.Shards) > 0 || s.HasField("shards") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shards")
		s.WriteStringArray(x.Shards)
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteShardsRequest to JSON.
func (x *StreamExecuteShardsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteShardsRequest message from JSON.
func (x *StreamExecuteShardsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shards":
			s.AddField("shards")
			if s.ReadNil() {
				x.Shards = nil
				return
			}
			x.Shards = s.ReadStringArray()
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteShardsRequest from JSON.
func (x *StreamExecuteShardsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteShardsResponse message to JSON.
func (x *StreamExecuteShardsResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteShardsResponse to JSON.
func (x *StreamExecuteShardsResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteShardsResponse message from JSON.
func (x *StreamExecuteShardsResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteShardsResponse from JSON.
func (x *StreamExecuteShardsResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteKeyspaceIdsRequest message to JSON.
func (x *StreamExecuteKeyspaceIdsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.KeyspaceIds) > 0 || s.HasField("keyspaceIds") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceIds")
		s.WriteBytesArray(x.KeyspaceIds)
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteKeyspaceIdsRequest to JSON.
func (x *StreamExecuteKeyspaceIdsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteKeyspaceIdsRequest message from JSON.
func (x *StreamExecuteKeyspaceIdsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "keyspace_ids", "keyspaceIds":
			s.AddField("keyspace_ids")
			if s.ReadNil() {
				x.KeyspaceIds = nil
				return
			}
			x.KeyspaceIds = s.ReadBytesArray()
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteKeyspaceIdsRequest from JSON.
func (x *StreamExecuteKeyspaceIdsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteKeyspaceIdsResponse message to JSON.
func (x *StreamExecuteKeyspaceIdsResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteKeyspaceIdsResponse to JSON.
func (x *StreamExecuteKeyspaceIdsResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteKeyspaceIdsResponse message from JSON.
func (x *StreamExecuteKeyspaceIdsResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteKeyspaceIdsResponse from JSON.
func (x *StreamExecuteKeyspaceIdsResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteKeyRangesRequest message to JSON.
func (x *StreamExecuteKeyRangesRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.KeyRanges) > 0 || s.HasField("keyRanges") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRanges")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.KeyRanges {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("keyRanges"))
		}
		s.WriteArrayEnd()
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.Options != nil || s.HasField("options") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("options")
		x.Options.MarshalProtoJSON(s.WithField("options"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteKeyRangesRequest to JSON.
func (x *StreamExecuteKeyRangesRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteKeyRangesRequest message from JSON.
func (x *StreamExecuteKeyRangesRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "key_ranges", "keyRanges":
			s.AddField("key_ranges")
			if s.ReadNil() {
				x.KeyRanges = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.KeyRanges = append(x.KeyRanges, nil)
					return
				}
				v := &topodata.KeyRange{}
				v.UnmarshalProtoJSON(s.WithField("key_ranges", false))
				if s.Err() != nil {
					return
				}
				x.KeyRanges = append(x.KeyRanges, v)
			})
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "options":
			if s.ReadNil() {
				x.Options = nil
				return
			}
			x.Options = &query.ExecuteOptions{}
			x.Options.UnmarshalProtoJSON(s.WithField("options", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteKeyRangesRequest from JSON.
func (x *StreamExecuteKeyRangesRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the StreamExecuteKeyRangesResponse message to JSON.
func (x *StreamExecuteKeyRangesResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Result != nil || s.HasField("result") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("result")
		x.Result.MarshalProtoJSON(s.WithField("result"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the StreamExecuteKeyRangesResponse to JSON.
func (x *StreamExecuteKeyRangesResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StreamExecuteKeyRangesResponse message from JSON.
func (x *StreamExecuteKeyRangesResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "result":
			if s.ReadNil() {
				x.Result = nil
				return
			}
			x.Result = &query.QueryResult{}
			x.Result.UnmarshalProtoJSON(s.WithField("result", true))
		}
	})
}

// UnmarshalJSON unmarshals the StreamExecuteKeyRangesResponse from JSON.
func (x *StreamExecuteKeyRangesResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the BeginRequest message to JSON.
func (x *BeginRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.SingleDb || s.HasField("singleDb") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("singleDb")
		s.WriteBool(x.SingleDb)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the BeginRequest to JSON.
func (x *BeginRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the BeginRequest message from JSON.
func (x *BeginRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "single_db", "singleDb":
			s.AddField("single_db")
			x.SingleDb = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the BeginRequest from JSON.
func (x *BeginRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the BeginResponse message to JSON.
func (x *BeginResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the BeginResponse to JSON.
func (x *BeginResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the BeginResponse message from JSON.
func (x *BeginResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		}
	})
}

// UnmarshalJSON unmarshals the BeginResponse from JSON.
func (x *BeginResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the CommitRequest message to JSON.
func (x *CommitRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	if x.Atomic || s.HasField("atomic") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("atomic")
		s.WriteBool(x.Atomic)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the CommitRequest to JSON.
func (x *CommitRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the CommitRequest message from JSON.
func (x *CommitRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		case "atomic":
			s.AddField("atomic")
			x.Atomic = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the CommitRequest from JSON.
func (x *CommitRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the CommitResponse message to JSON.
func (x *CommitResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	s.WriteObjectEnd()
}

// MarshalJSON marshals the CommitResponse to JSON.
func (x *CommitResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the CommitResponse message from JSON.
func (x *CommitResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
}

// UnmarshalJSON unmarshals the CommitResponse from JSON.
func (x *CommitResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the RollbackRequest message to JSON.
func (x *RollbackRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Session != nil || s.HasField("session") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("session")
		x.Session.MarshalProtoJSON(s.WithField("session"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the RollbackRequest to JSON.
func (x *RollbackRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the RollbackRequest message from JSON.
func (x *RollbackRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "session":
			if s.ReadNil() {
				x.Session = nil
				return
			}
			x.Session = &Session{}
			x.Session.UnmarshalProtoJSON(s.WithField("session", true))
		}
	})
}

// UnmarshalJSON unmarshals the RollbackRequest from JSON.
func (x *RollbackRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the RollbackResponse message to JSON.
func (x *RollbackResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	s.WriteObjectEnd()
}

// MarshalJSON marshals the RollbackResponse to JSON.
func (x *RollbackResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the RollbackResponse message from JSON.
func (x *RollbackResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
}

// UnmarshalJSON unmarshals the RollbackResponse from JSON.
func (x *RollbackResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ResolveTransactionRequest message to JSON.
func (x *ResolveTransactionRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Dtid != "" || s.HasField("dtid") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("dtid")
		s.WriteString(x.Dtid)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ResolveTransactionRequest to JSON.
func (x *ResolveTransactionRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ResolveTransactionRequest message from JSON.
func (x *ResolveTransactionRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "dtid":
			s.AddField("dtid")
			x.Dtid = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the ResolveTransactionRequest from JSON.
func (x *ResolveTransactionRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the MessageStreamRequest message to JSON.
func (x *MessageStreamRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.Shard != "" || s.HasField("shard") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shard")
		s.WriteString(x.Shard)
	}
	if x.KeyRange != nil || s.HasField("keyRange") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRange")
		x.KeyRange.MarshalProtoJSON(s.WithField("keyRange"))
	}
	if x.Name != "" || s.HasField("name") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("name")
		s.WriteString(x.Name)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the MessageStreamRequest to JSON.
func (x *MessageStreamRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the MessageStreamRequest message from JSON.
func (x *MessageStreamRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shard":
			s.AddField("shard")
			x.Shard = s.ReadString()
		case "key_range", "keyRange":
			if s.ReadNil() {
				x.KeyRange = nil
				return
			}
			x.KeyRange = &topodata.KeyRange{}
			x.KeyRange.UnmarshalProtoJSON(s.WithField("key_range", true))
		case "name":
			s.AddField("name")
			x.Name = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the MessageStreamRequest from JSON.
func (x *MessageStreamRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the MessageAckRequest message to JSON.
func (x *MessageAckRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.Name != "" || s.HasField("name") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("name")
		s.WriteString(x.Name)
	}
	if len(x.Ids) > 0 || s.HasField("ids") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("ids")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Ids {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("ids"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the MessageAckRequest to JSON.
func (x *MessageAckRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the MessageAckRequest message from JSON.
func (x *MessageAckRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "name":
			s.AddField("name")
			x.Name = s.ReadString()
		case "ids":
			s.AddField("ids")
			if s.ReadNil() {
				x.Ids = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Ids = append(x.Ids, nil)
					return
				}
				v := &query.Value{}
				v.UnmarshalProtoJSON(s.WithField("ids", false))
				if s.Err() != nil {
					return
				}
				x.Ids = append(x.Ids, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the MessageAckRequest from JSON.
func (x *MessageAckRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the IdKeyspaceId message to JSON.
func (x *IdKeyspaceId) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Id != nil || s.HasField("id") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("id")
		x.Id.MarshalProtoJSON(s.WithField("id"))
	}
	if len(x.KeyspaceId) > 0 || s.HasField("keyspaceId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceId")
		s.WriteBytes(x.KeyspaceId)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the IdKeyspaceId to JSON.
func (x *IdKeyspaceId) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the IdKeyspaceId message from JSON.
func (x *IdKeyspaceId) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "id":
			if s.ReadNil() {
				x.Id = nil
				return
			}
			x.Id = &query.Value{}
			x.Id.UnmarshalProtoJSON(s.WithField("id", true))
		case "keyspace_id", "keyspaceId":
			s.AddField("keyspace_id")
			x.KeyspaceId = s.ReadBytes()
		}
	})
}

// UnmarshalJSON unmarshals the IdKeyspaceId from JSON.
func (x *IdKeyspaceId) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the MessageAckKeyspaceIdsRequest message to JSON.
func (x *MessageAckKeyspaceIdsRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.Name != "" || s.HasField("name") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("name")
		s.WriteString(x.Name)
	}
	if len(x.IdKeyspaceIds) > 0 || s.HasField("idKeyspaceIds") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("idKeyspaceIds")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.IdKeyspaceIds {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("idKeyspaceIds"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the MessageAckKeyspaceIdsRequest to JSON.
func (x *MessageAckKeyspaceIdsRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the MessageAckKeyspaceIdsRequest message from JSON.
func (x *MessageAckKeyspaceIdsRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "name":
			s.AddField("name")
			x.Name = s.ReadString()
		case "id_keyspace_ids", "idKeyspaceIds":
			s.AddField("id_keyspace_ids")
			if s.ReadNil() {
				x.IdKeyspaceIds = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.IdKeyspaceIds = append(x.IdKeyspaceIds, nil)
					return
				}
				v := &IdKeyspaceId{}
				v.UnmarshalProtoJSON(s.WithField("id_keyspace_ids", false))
				if s.Err() != nil {
					return
				}
				x.IdKeyspaceIds = append(x.IdKeyspaceIds, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the MessageAckKeyspaceIdsRequest from JSON.
func (x *MessageAckKeyspaceIdsRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ResolveTransactionResponse message to JSON.
func (x *ResolveTransactionResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ResolveTransactionResponse to JSON.
func (x *ResolveTransactionResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ResolveTransactionResponse message from JSON.
func (x *ResolveTransactionResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
}

// UnmarshalJSON unmarshals the ResolveTransactionResponse from JSON.
func (x *ResolveTransactionResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SplitQueryRequest message to JSON.
func (x *SplitQueryRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if len(x.SplitColumn) > 0 || s.HasField("splitColumn") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("splitColumn")
		s.WriteStringArray(x.SplitColumn)
	}
	if x.SplitCount != 0 || s.HasField("splitCount") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("splitCount")
		s.WriteInt64(x.SplitCount)
	}
	if x.NumRowsPerQueryPart != 0 || s.HasField("numRowsPerQueryPart") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("numRowsPerQueryPart")
		s.WriteInt64(x.NumRowsPerQueryPart)
	}
	if x.Algorithm != 0 || s.HasField("algorithm") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("algorithm")
		x.Algorithm.MarshalProtoJSON(s)
	}
	if x.UseSplitQueryV2 || s.HasField("useSplitQueryV2") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("useSplitQueryV2")
		s.WriteBool(x.UseSplitQueryV2)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SplitQueryRequest to JSON.
func (x *SplitQueryRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SplitQueryRequest message from JSON.
func (x *SplitQueryRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "split_column", "splitColumn":
			s.AddField("split_column")
			if s.ReadNil() {
				x.SplitColumn = nil
				return
			}
			x.SplitColumn = s.ReadStringArray()
		case "split_count", "splitCount":
			s.AddField("split_count")
			x.SplitCount = s.ReadInt64()
		case "num_rows_per_query_part", "numRowsPerQueryPart":
			s.AddField("num_rows_per_query_part")
			x.NumRowsPerQueryPart = s.ReadInt64()
		case "algorithm":
			s.AddField("algorithm")
			x.Algorithm.UnmarshalProtoJSON(s)
		case "use_split_query_v2", "useSplitQueryV2":
			s.AddField("use_split_query_v2")
			x.UseSplitQueryV2 = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the SplitQueryRequest from JSON.
func (x *SplitQueryRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SplitQueryResponse_KeyRangePart message to JSON.
func (x *SplitQueryResponse_KeyRangePart) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.KeyRanges) > 0 || s.HasField("keyRanges") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRanges")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.KeyRanges {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("keyRanges"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SplitQueryResponse_KeyRangePart to JSON.
func (x *SplitQueryResponse_KeyRangePart) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SplitQueryResponse_KeyRangePart message from JSON.
func (x *SplitQueryResponse_KeyRangePart) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "key_ranges", "keyRanges":
			s.AddField("key_ranges")
			if s.ReadNil() {
				x.KeyRanges = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.KeyRanges = append(x.KeyRanges, nil)
					return
				}
				v := &topodata.KeyRange{}
				v.UnmarshalProtoJSON(s.WithField("key_ranges", false))
				if s.Err() != nil {
					return
				}
				x.KeyRanges = append(x.KeyRanges, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the SplitQueryResponse_KeyRangePart from JSON.
func (x *SplitQueryResponse_KeyRangePart) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SplitQueryResponse_ShardPart message to JSON.
func (x *SplitQueryResponse_ShardPart) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if len(x.Shards) > 0 || s.HasField("shards") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shards")
		s.WriteStringArray(x.Shards)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SplitQueryResponse_ShardPart to JSON.
func (x *SplitQueryResponse_ShardPart) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SplitQueryResponse_ShardPart message from JSON.
func (x *SplitQueryResponse_ShardPart) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shards":
			s.AddField("shards")
			if s.ReadNil() {
				x.Shards = nil
				return
			}
			x.Shards = s.ReadStringArray()
		}
	})
}

// UnmarshalJSON unmarshals the SplitQueryResponse_ShardPart from JSON.
func (x *SplitQueryResponse_ShardPart) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SplitQueryResponse_Part message to JSON.
func (x *SplitQueryResponse_Part) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Query != nil || s.HasField("query") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("query")
		x.Query.MarshalProtoJSON(s.WithField("query"))
	}
	if x.KeyRangePart != nil || s.HasField("keyRangePart") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRangePart")
		x.KeyRangePart.MarshalProtoJSON(s.WithField("keyRangePart"))
	}
	if x.ShardPart != nil || s.HasField("shardPart") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardPart")
		x.ShardPart.MarshalProtoJSON(s.WithField("shardPart"))
	}
	if x.Size != 0 || s.HasField("size") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("size")
		s.WriteInt64(x.Size)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SplitQueryResponse_Part to JSON.
func (x *SplitQueryResponse_Part) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SplitQueryResponse_Part message from JSON.
func (x *SplitQueryResponse_Part) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "query":
			if s.ReadNil() {
				x.Query = nil
				return
			}
			x.Query = &query.BoundQuery{}
			x.Query.UnmarshalProtoJSON(s.WithField("query", true))
		case "key_range_part", "keyRangePart":
			if s.ReadNil() {
				x.KeyRangePart = nil
				return
			}
			x.KeyRangePart = &SplitQueryResponse_KeyRangePart{}
			x.KeyRangePart.UnmarshalProtoJSON(s.WithField("key_range_part", true))
		case "shard_part", "shardPart":
			if s.ReadNil() {
				x.ShardPart = nil
				return
			}
			x.ShardPart = &SplitQueryResponse_ShardPart{}
			x.ShardPart.UnmarshalProtoJSON(s.WithField("shard_part", true))
		case "size":
			s.AddField("size")
			x.Size = s.ReadInt64()
		}
	})
}

// UnmarshalJSON unmarshals the SplitQueryResponse_Part from JSON.
func (x *SplitQueryResponse_Part) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SplitQueryResponse message to JSON.
func (x *SplitQueryResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Splits) > 0 || s.HasField("splits") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("splits")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Splits {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("splits"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SplitQueryResponse to JSON.
func (x *SplitQueryResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SplitQueryResponse message from JSON.
func (x *SplitQueryResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "splits":
			s.AddField("splits")
			if s.ReadNil() {
				x.Splits = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Splits = append(x.Splits, nil)
					return
				}
				v := &SplitQueryResponse_Part{}
				v.UnmarshalProtoJSON(s.WithField("splits", false))
				if s.Err() != nil {
					return
				}
				x.Splits = append(x.Splits, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the SplitQueryResponse from JSON.
func (x *SplitQueryResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the GetSrvKeyspaceRequest message to JSON.
func (x *GetSrvKeyspaceRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the GetSrvKeyspaceRequest to JSON.
func (x *GetSrvKeyspaceRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the GetSrvKeyspaceRequest message from JSON.
func (x *GetSrvKeyspaceRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the GetSrvKeyspaceRequest from JSON.
func (x *GetSrvKeyspaceRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the GetSrvKeyspaceResponse message to JSON.
func (x *GetSrvKeyspaceResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.SrvKeyspace != nil || s.HasField("srvKeyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("srvKeyspace")
		x.SrvKeyspace.MarshalProtoJSON(s.WithField("srvKeyspace"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the GetSrvKeyspaceResponse to JSON.
func (x *GetSrvKeyspaceResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the GetSrvKeyspaceResponse message from JSON.
func (x *GetSrvKeyspaceResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "srv_keyspace", "srvKeyspace":
			if s.ReadNil() {
				x.SrvKeyspace = nil
				return
			}
			x.SrvKeyspace = &topodata.SrvKeyspace{}
			x.SrvKeyspace.UnmarshalProtoJSON(s.WithField("srv_keyspace", true))
		}
	})
}

// UnmarshalJSON unmarshals the GetSrvKeyspaceResponse from JSON.
func (x *GetSrvKeyspaceResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the VStreamRequest message to JSON.
func (x *VStreamRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.Vgtid != nil || s.HasField("vgtid") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("vgtid")
		x.Vgtid.MarshalProtoJSON(s.WithField("vgtid"))
	}
	if x.Filter != nil || s.HasField("filter") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("filter")
		x.Filter.MarshalProtoJSON(s.WithField("filter"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the VStreamRequest to JSON.
func (x *VStreamRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the VStreamRequest message from JSON.
func (x *VStreamRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "vgtid":
			if s.ReadNil() {
				x.Vgtid = nil
				return
			}
			x.Vgtid = &binlogdata.VGtid{}
			x.Vgtid.UnmarshalProtoJSON(s.WithField("vgtid", true))
		case "filter":
			if s.ReadNil() {
				x.Filter = nil
				return
			}
			x.Filter = &binlogdata.Filter{}
			x.Filter.UnmarshalProtoJSON(s.WithField("filter", true))
		}
	})
}

// UnmarshalJSON unmarshals the VStreamRequest from JSON.
func (x *VStreamRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the VStreamResponse message to JSON.
func (x *VStreamResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Events) > 0 || s.HasField("events") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("events")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Events {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("events"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the VStreamResponse to JSON.
func (x *VStreamResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the VStreamResponse message from JSON.
func (x *VStreamResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "events":
			s.AddField("events")
			if s.ReadNil() {
				x.Events = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Events = append(x.Events, nil)
					return
				}
				v := &binlogdata.VEvent{}
				v.UnmarshalProtoJSON(s.WithField("events", false))
				if s.Err() != nil {
					return
				}
				x.Events = append(x.Events, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the VStreamResponse from JSON.
func (x *VStreamResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the UpdateStreamRequest message to JSON.
func (x *UpdateStreamRequest) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.CallerId != nil || s.HasField("callerId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("callerId")
		x.CallerId.MarshalProtoJSON(s.WithField("callerId"))
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.Shard != "" || s.HasField("shard") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shard")
		s.WriteString(x.Shard)
	}
	if x.KeyRange != nil || s.HasField("keyRange") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRange")
		x.KeyRange.MarshalProtoJSON(s.WithField("keyRange"))
	}
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.Timestamp != 0 || s.HasField("timestamp") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("timestamp")
		s.WriteInt64(x.Timestamp)
	}
	if x.Event != nil || s.HasField("event") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("event")
		x.Event.MarshalProtoJSON(s.WithField("event"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the UpdateStreamRequest to JSON.
func (x *UpdateStreamRequest) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the UpdateStreamRequest message from JSON.
func (x *UpdateStreamRequest) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "caller_id", "callerId":
			if s.ReadNil() {
				x.CallerId = nil
				return
			}
			x.CallerId = &vtrpc.CallerID{}
			x.CallerId.UnmarshalProtoJSON(s.WithField("caller_id", true))
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shard":
			s.AddField("shard")
			x.Shard = s.ReadString()
		case "key_range", "keyRange":
			if s.ReadNil() {
				x.KeyRange = nil
				return
			}
			x.KeyRange = &topodata.KeyRange{}
			x.KeyRange.UnmarshalProtoJSON(s.WithField("key_range", true))
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "timestamp":
			s.AddField("timestamp")
			x.Timestamp = s.ReadInt64()
		case "event":
			if s.ReadNil() {
				x.Event = nil
				return
			}
			x.Event = &query.EventToken{}
			x.Event.UnmarshalProtoJSON(s.WithField("event", true))
		}
	})
}

// UnmarshalJSON unmarshals the UpdateStreamRequest from JSON.
func (x *UpdateStreamRequest) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the UpdateStreamResponse message to JSON.
func (x *UpdateStreamResponse) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Event != nil || s.HasField("event") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("event")
		x.Event.MarshalProtoJSON(s.WithField("event"))
	}
	if x.ResumeTimestamp != 0 || s.HasField("resumeTimestamp") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("resumeTimestamp")
		s.WriteInt64(x.ResumeTimestamp)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the UpdateStreamResponse to JSON.
func (x *UpdateStreamResponse) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the UpdateStreamResponse message from JSON.
func (x *UpdateStreamResponse) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "event":
			if s.ReadNil() {
				x.Event = nil
				return
			}
			x.Event = &query.StreamEvent{}
			x.Event.UnmarshalProtoJSON(s.WithField("event", true))
		case "resume_timestamp", "resumeTimestamp":
			s.AddField("resume_timestamp")
			x.ResumeTimestamp = s.ReadInt64()
		}
	})
}

// UnmarshalJSON unmarshals the UpdateStreamResponse from JSON.
func (x *UpdateStreamResponse) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

func (m *Session_ShardSession) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session_ShardSession) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Session_ShardSession) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.TransactionId != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TransactionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Target != nil {
		size, err := m.Target.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Session) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.PostSessions) > 0 {
		for iNdEx := len(m.PostSessions) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.PostSessions[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PreSessions) > 0 {
		for iNdEx := len(m.PreSessions) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.PreSessions[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Warnings) > 0 {
		for iNdEx := len(m.Warnings) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Warnings[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.TransactionMode != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TransactionMode))
		i--
		dAtA[i] = 0x38
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TargetString) > 0 {
		i -= len(m.TargetString)
		copy(dAtA[i:], m.TargetString)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.TargetString)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Autocommit {
		i--
		if m.Autocommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SingleDb {
		i--
		if m.SingleDb {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ShardSessions) > 0 {
		for iNdEx := len(m.ShardSessions) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ShardSessions[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.InTransaction {
		i--
		if m.InTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.KeyspaceShard) > 0 {
		i -= len(m.KeyspaceShard)
		copy(dAtA[i:], m.KeyspaceShard)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceShard)))
		i--
		dAtA[i] = 0x32
	}
	if m.NotInTransaction {
		i--
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x20
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteShardsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteShardsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteShardsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.NotInTransaction {
		i--
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Shards[iNdEx])
			copy(dAtA[i:], m.Shards[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shards[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x22
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteShardsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteShardsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteShardsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteKeyspaceIdsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyspaceIdsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteKeyspaceIdsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.NotInTransaction {
		i--
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.KeyspaceIds) > 0 {
		for iNdEx := len(m.KeyspaceIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyspaceIds[iNdEx])
			copy(dAtA[i:], m.KeyspaceIds[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceIds[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x22
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteKeyspaceIdsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyspaceIdsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteKeyspaceIdsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteKeyRangesRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyRangesRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteKeyRangesRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.NotInTransaction {
		i--
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.KeyRanges) > 0 {
		for iNdEx := len(m.KeyRanges) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.KeyRanges[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x22
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteKeyRangesResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyRangesResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteKeyRangesResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteEntityIdsRequest_EntityId) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteEntityIdsRequest_EntityId) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteEntityIdsRequest_EntityId) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.KeyspaceId) > 0 {
		i -= len(m.KeyspaceId)
		copy(dAtA[i:], m.KeyspaceId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteEntityIdsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteEntityIdsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteEntityIdsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	}
	if m.NotInTransaction {
		i--
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.EntityKeyspaceIds) > 0 {
		for iNdEx := len(m.EntityKeyspaceIds) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.EntityKeyspaceIds[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EntityColumnName) > 0 {
		i -= len(m.EntityColumnName)
		copy(dAtA[i:], m.EntityColumnName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.EntityColumnName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x22
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteEntityIdsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteEntityIdsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteEntityIdsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteBatchRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.KeyspaceShard) > 0 {
		i -= len(m.KeyspaceShard)
		copy(dAtA[i:], m.KeyspaceShard)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceShard)))
		i--
		dAtA[i] = 0x32
	}
	if m.AsTransaction {
		i--
		if m.AsTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Queries) > 0 {
		for iNdEx := len(m.Queries) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Queries[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteBatchResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Results[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BoundShardQuery) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundShardQuery) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BoundShardQuery) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Shards[iNdEx])
			copy(dAtA[i:], m.Shards[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shards[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchShardsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchShardsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteBatchShardsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.AsTransaction {
		i--
		if m.AsTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Queries) > 0 {
		for iNdEx := len(m.Queries) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Queries[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchShardsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchShardsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteBatchShardsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Results[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BoundKeyspaceIdQuery) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundKeyspaceIdQuery) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BoundKeyspaceIdQuery) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.KeyspaceIds) > 0 {
		for iNdEx := len(m.KeyspaceIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyspaceIds[iNdEx])
			copy(dAtA[i:], m.KeyspaceIds[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteBatchKeyspaceIdsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.AsTransaction {
		i--
		if m.AsTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Queries) > 0 {
		for iNdEx := len(m.Queries) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Queries[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExecuteBatchKeyspaceIdsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Results[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		size, err := m.Error.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyspaceShard) > 0 {
		i -= len(m.KeyspaceShard)
		copy(dAtA[i:], m.KeyspaceShard)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceShard)))
		i--
		dAtA[i] = 0x22
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x18
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteShardsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteShardsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteShardsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Shards[iNdEx])
			copy(dAtA[i:], m.Shards[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shards[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteShardsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteShardsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteShardsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteKeyspaceIdsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyspaceIdsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteKeyspaceIdsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.KeyspaceIds) > 0 {
		for iNdEx := len(m.KeyspaceIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyspaceIds[iNdEx])
			copy(dAtA[i:], m.KeyspaceIds[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteKeyspaceIdsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyspaceIdsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteKeyspaceIdsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteKeyRangesRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyRangesRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteKeyRangesRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.KeyRanges) > 0 {
		for iNdEx := len(m.KeyRanges) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.KeyRanges[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteKeyRangesResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyRangesResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StreamExecuteKeyRangesResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Result != nil {
		size, err := m.Result.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeginRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BeginRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.SingleDb {
		i--
		if m.SingleDb {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeginResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BeginResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CommitRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Atomic {
		i--
		if m.Atomic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CommitResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *RollbackRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *RollbackRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Session != nil {
		size, err := m.Session.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RollbackResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *RollbackResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *ResolveTransactionRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveTransactionRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ResolveTransactionRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Dtid) > 0 {
		i -= len(m.Dtid)
		copy(dAtA[i:], m.Dtid)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Dtid)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageStreamRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageStreamRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MessageStreamRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.KeyRange != nil {
		size, err := m.KeyRange.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageAckRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageAckRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MessageAckRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Ids[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdKeyspaceId) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdKeyspaceId) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *IdKeyspaceId) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.KeyspaceId) > 0 {
		i -= len(m.KeyspaceId)
		copy(dAtA[i:], m.KeyspaceId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.KeyspaceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		size, err := m.Id.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageAckKeyspaceIdsRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageAckKeyspaceIdsRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MessageAckKeyspaceIdsRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.IdKeyspaceIds) > 0 {
		for iNdEx := len(m.IdKeyspaceIds) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.IdKeyspaceIds[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolveTransactionResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveTransactionResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ResolveTransactionResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *SplitQueryRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SplitQueryRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.UseSplitQueryV2 {
		i--
		if m.UseSplitQueryV2 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Algorithm != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x38
	}
	if m.NumRowsPerQueryPart != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.NumRowsPerQueryPart))
		i--
		dAtA[i] = 0x30
	}
	if m.SplitCount != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.SplitCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SplitColumn) > 0 {
		for iNdEx := len(m.SplitColumn) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SplitColumn[iNdEx])
			copy(dAtA[i:], m.SplitColumn[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.SplitColumn[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitQueryResponse_KeyRangePart) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse_KeyRangePart) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SplitQueryResponse_KeyRangePart) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.KeyRanges) > 0 {
		for iNdEx := len(m.KeyRanges) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.KeyRanges[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitQueryResponse_ShardPart) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse_ShardPart) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SplitQueryResponse_ShardPart) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Shards[iNdEx])
			copy(dAtA[i:], m.Shards[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shards[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitQueryResponse_Part) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse_Part) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SplitQueryResponse_Part) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Size != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Size))
		i--
		dAtA[i] = 0x20
	}
	if m.ShardPart != nil {
		size, err := m.ShardPart.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.KeyRangePart != nil {
		size, err := m.KeyRangePart.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Query != nil {
		size, err := m.Query.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitQueryResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SplitQueryResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Splits) > 0 {
		for iNdEx := len(m.Splits) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Splits[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSrvKeyspaceRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSrvKeyspaceRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetSrvKeyspaceRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSrvKeyspaceResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSrvKeyspaceResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetSrvKeyspaceResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.SrvKeyspace != nil {
		size, err := m.SrvKeyspace.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VStreamRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *VStreamRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Filter != nil {
		size, err := m.Filter.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.Vgtid != nil {
		size, err := m.Vgtid.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x10
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VStreamResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *VStreamResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Events[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateStreamRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStreamRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UpdateStreamRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Event != nil {
		size, err := m.Event.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if m.Timestamp != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x28
	}
	if m.KeyRange != nil {
		size, err := m.KeyRange.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		size, err := m.CallerId.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateStreamResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStreamResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UpdateStreamResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.ResumeTimestamp != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.ResumeTimestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Event != nil {
		size, err := m.Event.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session_ShardSession) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.TransactionId != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TransactionId))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Session) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InTransaction {
		n += 2
	}
	if len(m.ShardSessions) > 0 {
		for _, e := range m.ShardSessions {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.SingleDb {
		n += 2
	}
	if m.Autocommit {
		n += 2
	}
	l = len(m.TargetString)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.TransactionMode != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TransactionMode))
	}
	if len(m.Warnings) > 0 {
		for _, e := range m.Warnings {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.PreSessions) > 0 {
		for _, e := range m.PreSessions {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.PostSessions) > 0 {
		for _, e := range m.PostSessions {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteShardsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteShardsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteKeyspaceIdsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			l = len(b)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteKeyspaceIdsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteKeyRangesRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteKeyRangesResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteEntityIdsRequest_EntityId) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.KeyspaceId)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteEntityIdsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.EntityColumnName)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.EntityKeyspaceIds) > 0 {
		for _, e := range m.EntityKeyspaceIds {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteEntityIdsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteBatchRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.AsTransaction {
		n += 2
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteBatchResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *BoundShardQuery) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteBatchShardsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.AsTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteBatchShardsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *BoundKeyspaceIdQuery) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			l = len(b)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteBatchKeyspaceIdsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.AsTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExecuteBatchKeyspaceIdsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteShardsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteShardsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteKeyspaceIdsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			l = len(b)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteKeyspaceIdsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteKeyRangesRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StreamExecuteKeyRangesResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *BeginRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.SingleDb {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *BeginResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *CommitRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Atomic {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *CommitResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *RollbackRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *RollbackResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *ResolveTransactionRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Dtid)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *MessageStreamRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *MessageAckRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *IdKeyspaceId) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.KeyspaceId)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *MessageAckKeyspaceIdsRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.IdKeyspaceIds) > 0 {
		for _, e := range m.IdKeyspaceIds {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ResolveTransactionResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *SplitQueryRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.SplitColumn) > 0 {
		for _, s := range m.SplitColumn {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.SplitCount != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.SplitCount))
	}
	if m.NumRowsPerQueryPart != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.NumRowsPerQueryPart))
	}
	if m.Algorithm != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Algorithm))
	}
	if m.UseSplitQueryV2 {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *SplitQueryResponse_KeyRangePart) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *SplitQueryResponse_ShardPart) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *SplitQueryResponse_Part) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRangePart != nil {
		l = m.KeyRangePart.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.ShardPart != nil {
		l = m.ShardPart.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Size != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Size))
	}
	n += len(m.unknownFields)
	return n
}

func (m *SplitQueryResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Splits) > 0 {
		for _, e := range m.Splits {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetSrvKeyspaceRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetSrvKeyspaceResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrvKeyspace != nil {
		l = m.SrvKeyspace.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *VStreamRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.Vgtid != nil {
		l = m.Vgtid.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *VStreamResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *UpdateStreamRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if m.Timestamp != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Timestamp))
	}
	if m.Event != nil {
		l = m.Event.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *UpdateStreamResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.ResumeTimestamp != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.ResumeTimestamp))
	}
	n += len(m.unknownFields)
	return n
}

func (x TransactionMode) MarshalProtoText() string {
	return x.String()
}
func (x CommitOrder) MarshalProtoText() string {
	return x.String()
}
func (x *Session_ShardSession) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ShardSession { ")
	if x.Target != nil {
		sb.WriteString(" target: ")
		sb.WriteString(x.Target.MarshalProtoText())
	}
	if x.TransactionId != 0 {
		sb.WriteString(" transaction_id: ")
		sb.WriteString(strconv.FormatInt(int64(x.TransactionId), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Session_ShardSession) String() string {
	return x.MarshalProtoText()
}
func (x *Session) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Session { ")
	if x.InTransaction {
		sb.WriteString(" in_transaction: ")
		sb.WriteString(strconv.FormatBool(x.InTransaction))
	}
	if len(x.ShardSessions) > 0 {
		sb.WriteString(" shard_sessions: [")
		for i, v := range x.ShardSessions {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.SingleDb {
		sb.WriteString(" single_db: ")
		sb.WriteString(strconv.FormatBool(x.SingleDb))
	}
	if x.Autocommit {
		sb.WriteString(" autocommit: ")
		sb.WriteString(strconv.FormatBool(x.Autocommit))
	}
	if x.TargetString != "" {
		sb.WriteString(" target_string: ")
		sb.WriteString(strconv.Quote(x.TargetString))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	if x.TransactionMode != 0 {
		sb.WriteString(" transaction_mode: ")
		sb.WriteString(TransactionMode(x.TransactionMode).String())
	}
	if len(x.Warnings) > 0 {
		sb.WriteString(" warnings: [")
		for i, v := range x.Warnings {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.PreSessions) > 0 {
		sb.WriteString(" pre_sessions: [")
		for i, v := range x.PreSessions {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.PostSessions) > 0 {
		sb.WriteString(" post_sessions: [")
		for i, v := range x.PostSessions {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Session) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.NotInTransaction {
		sb.WriteString(" not_in_transaction: ")
		sb.WriteString(strconv.FormatBool(x.NotInTransaction))
	}
	if x.KeyspaceShard != "" {
		sb.WriteString(" keyspace_shard: ")
		sb.WriteString(strconv.Quote(x.KeyspaceShard))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteResponse) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteShardsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteShardsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.Shards) > 0 {
		sb.WriteString(" shards: [")
		for i, v := range x.Shards {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.NotInTransaction {
		sb.WriteString(" not_in_transaction: ")
		sb.WriteString(strconv.FormatBool(x.NotInTransaction))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteShardsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteShardsResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteShardsResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteShardsResponse) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteKeyspaceIdsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteKeyspaceIdsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.KeyspaceIds) > 0 {
		sb.WriteString(" keyspace_ids: [")
		for i, v := range x.KeyspaceIds {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString("\"")
			sb.WriteString(base64.StdEncoding.EncodeToString(v))
			sb.WriteString("\"")
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.NotInTransaction {
		sb.WriteString(" not_in_transaction: ")
		sb.WriteString(strconv.FormatBool(x.NotInTransaction))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteKeyspaceIdsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteKeyspaceIdsResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteKeyspaceIdsResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteKeyspaceIdsResponse) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteKeyRangesRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteKeyRangesRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.KeyRanges) > 0 {
		sb.WriteString(" key_ranges: [")
		for i, v := range x.KeyRanges {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.NotInTransaction {
		sb.WriteString(" not_in_transaction: ")
		sb.WriteString(strconv.FormatBool(x.NotInTransaction))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteKeyRangesRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteKeyRangesResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteKeyRangesResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteKeyRangesResponse) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteEntityIdsRequest_EntityId) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EntityId { ")
	if x.Type != 0 {
		sb.WriteString(" type: ")
		sb.WriteString(query.Type(x.Type).String())
	}
	if len(x.Value) > 0 {
		sb.WriteString(" value: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Value))
		sb.WriteString("\"")
	}
	if len(x.KeyspaceId) > 0 {
		sb.WriteString(" keyspace_id: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.KeyspaceId))
		sb.WriteString("\"")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteEntityIdsRequest_EntityId) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteEntityIdsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteEntityIdsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.EntityColumnName != "" {
		sb.WriteString(" entity_column_name: ")
		sb.WriteString(strconv.Quote(x.EntityColumnName))
	}
	if len(x.EntityKeyspaceIds) > 0 {
		sb.WriteString(" entity_keyspace_ids: [")
		for i, v := range x.EntityKeyspaceIds {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.NotInTransaction {
		sb.WriteString(" not_in_transaction: ")
		sb.WriteString(strconv.FormatBool(x.NotInTransaction))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteEntityIdsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteEntityIdsResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteEntityIdsResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteEntityIdsResponse) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteBatchRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteBatchRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if len(x.Queries) > 0 {
		sb.WriteString(" queries: [")
		for i, v := range x.Queries {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.AsTransaction {
		sb.WriteString(" as_transaction: ")
		sb.WriteString(strconv.FormatBool(x.AsTransaction))
	}
	if x.KeyspaceShard != "" {
		sb.WriteString(" keyspace_shard: ")
		sb.WriteString(strconv.Quote(x.KeyspaceShard))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteBatchRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteBatchResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteBatchResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if len(x.Results) > 0 {
		sb.WriteString(" results: [")
		for i, v := range x.Results {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteBatchResponse) String() string {
	return x.MarshalProtoText()
}
func (x *BoundShardQuery) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("BoundShardQuery { ")
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.Shards) > 0 {
		sb.WriteString(" shards: [")
		for i, v := range x.Shards {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *BoundShardQuery) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteBatchShardsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteBatchShardsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if len(x.Queries) > 0 {
		sb.WriteString(" queries: [")
		for i, v := range x.Queries {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.AsTransaction {
		sb.WriteString(" as_transaction: ")
		sb.WriteString(strconv.FormatBool(x.AsTransaction))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteBatchShardsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteBatchShardsResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteBatchShardsResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if len(x.Results) > 0 {
		sb.WriteString(" results: [")
		for i, v := range x.Results {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteBatchShardsResponse) String() string {
	return x.MarshalProtoText()
}
func (x *BoundKeyspaceIdQuery) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("BoundKeyspaceIdQuery { ")
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.KeyspaceIds) > 0 {
		sb.WriteString(" keyspace_ids: [")
		for i, v := range x.KeyspaceIds {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString("\"")
			sb.WriteString(base64.StdEncoding.EncodeToString(v))
			sb.WriteString("\"")
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *BoundKeyspaceIdQuery) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteBatchKeyspaceIdsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteBatchKeyspaceIdsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if len(x.Queries) > 0 {
		sb.WriteString(" queries: [")
		for i, v := range x.Queries {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.AsTransaction {
		sb.WriteString(" as_transaction: ")
		sb.WriteString(strconv.FormatBool(x.AsTransaction))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteBatchKeyspaceIdsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ExecuteBatchKeyspaceIdsResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExecuteBatchKeyspaceIdsResponse { ")
	if x.Error != nil {
		sb.WriteString(" error: ")
		sb.WriteString(x.Error.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if len(x.Results) > 0 {
		sb.WriteString(" results: [")
		for i, v := range x.Results {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExecuteBatchKeyspaceIdsResponse) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.KeyspaceShard != "" {
		sb.WriteString(" keyspace_shard: ")
		sb.WriteString(strconv.Quote(x.KeyspaceShard))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteRequest) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteResponse { ")
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteResponse) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteShardsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteShardsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.Shards) > 0 {
		sb.WriteString(" shards: [")
		for i, v := range x.Shards {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteShardsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteShardsResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteShardsResponse { ")
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteShardsResponse) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteKeyspaceIdsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteKeyspaceIdsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.KeyspaceIds) > 0 {
		sb.WriteString(" keyspace_ids: [")
		for i, v := range x.KeyspaceIds {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString("\"")
			sb.WriteString(base64.StdEncoding.EncodeToString(v))
			sb.WriteString("\"")
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteKeyspaceIdsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteKeyspaceIdsResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteKeyspaceIdsResponse { ")
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteKeyspaceIdsResponse) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteKeyRangesRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteKeyRangesRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.KeyRanges) > 0 {
		sb.WriteString(" key_ranges: [")
		for i, v := range x.KeyRanges {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteKeyRangesRequest) String() string {
	return x.MarshalProtoText()
}
func (x *StreamExecuteKeyRangesResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StreamExecuteKeyRangesResponse { ")
	if x.Result != nil {
		sb.WriteString(" result: ")
		sb.WriteString(x.Result.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StreamExecuteKeyRangesResponse) String() string {
	return x.MarshalProtoText()
}
func (x *BeginRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("BeginRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.SingleDb {
		sb.WriteString(" single_db: ")
		sb.WriteString(strconv.FormatBool(x.SingleDb))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *BeginRequest) String() string {
	return x.MarshalProtoText()
}
func (x *BeginResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("BeginResponse { ")
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *BeginResponse) String() string {
	return x.MarshalProtoText()
}
func (x *CommitRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("CommitRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	if x.Atomic {
		sb.WriteString(" atomic: ")
		sb.WriteString(strconv.FormatBool(x.Atomic))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *CommitRequest) String() string {
	return x.MarshalProtoText()
}
func (x *CommitResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("CommitResponse { ")
	sb.WriteString("}")
	return sb.String()
}
func (x *CommitResponse) String() string {
	return x.MarshalProtoText()
}
func (x *RollbackRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("RollbackRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Session != nil {
		sb.WriteString(" session: ")
		sb.WriteString(x.Session.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *RollbackRequest) String() string {
	return x.MarshalProtoText()
}
func (x *RollbackResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("RollbackResponse { ")
	sb.WriteString("}")
	return sb.String()
}
func (x *RollbackResponse) String() string {
	return x.MarshalProtoText()
}
func (x *ResolveTransactionRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ResolveTransactionRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Dtid != "" {
		sb.WriteString(" dtid: ")
		sb.WriteString(strconv.Quote(x.Dtid))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ResolveTransactionRequest) String() string {
	return x.MarshalProtoText()
}
func (x *MessageStreamRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("MessageStreamRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.Shard != "" {
		sb.WriteString(" shard: ")
		sb.WriteString(strconv.Quote(x.Shard))
	}
	if x.KeyRange != nil {
		sb.WriteString(" key_range: ")
		sb.WriteString(x.KeyRange.MarshalProtoText())
	}
	if x.Name != "" {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(x.Name))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *MessageStreamRequest) String() string {
	return x.MarshalProtoText()
}
func (x *MessageAckRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("MessageAckRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.Name != "" {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(x.Name))
	}
	if len(x.Ids) > 0 {
		sb.WriteString(" ids: [")
		for i, v := range x.Ids {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *MessageAckRequest) String() string {
	return x.MarshalProtoText()
}
func (x *IdKeyspaceId) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("IdKeyspaceId { ")
	if x.Id != nil {
		sb.WriteString(" id: ")
		sb.WriteString(x.Id.MarshalProtoText())
	}
	if len(x.KeyspaceId) > 0 {
		sb.WriteString(" keyspace_id: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.KeyspaceId))
		sb.WriteString("\"")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *IdKeyspaceId) String() string {
	return x.MarshalProtoText()
}
func (x *MessageAckKeyspaceIdsRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("MessageAckKeyspaceIdsRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.Name != "" {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(x.Name))
	}
	if len(x.IdKeyspaceIds) > 0 {
		sb.WriteString(" id_keyspace_ids: [")
		for i, v := range x.IdKeyspaceIds {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *MessageAckKeyspaceIdsRequest) String() string {
	return x.MarshalProtoText()
}
func (x *ResolveTransactionResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ResolveTransactionResponse { ")
	sb.WriteString("}")
	return sb.String()
}
func (x *ResolveTransactionResponse) String() string {
	return x.MarshalProtoText()
}
func (x *SplitQueryRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("SplitQueryRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if len(x.SplitColumn) > 0 {
		sb.WriteString(" split_column: [")
		for i, v := range x.SplitColumn {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if x.SplitCount != 0 {
		sb.WriteString(" split_count: ")
		sb.WriteString(strconv.FormatInt(int64(x.SplitCount), 10))
	}
	if x.NumRowsPerQueryPart != 0 {
		sb.WriteString(" num_rows_per_query_part: ")
		sb.WriteString(strconv.FormatInt(int64(x.NumRowsPerQueryPart), 10))
	}
	if x.Algorithm != 0 {
		sb.WriteString(" algorithm: ")
		sb.WriteString(query.SplitQueryRequest_Algorithm(x.Algorithm).String())
	}
	if x.UseSplitQueryV2 {
		sb.WriteString(" use_split_query_v2: ")
		sb.WriteString(strconv.FormatBool(x.UseSplitQueryV2))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SplitQueryRequest) String() string {
	return x.MarshalProtoText()
}
func (x *SplitQueryResponse_KeyRangePart) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("KeyRangePart { ")
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.KeyRanges) > 0 {
		sb.WriteString(" key_ranges: [")
		for i, v := range x.KeyRanges {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SplitQueryResponse_KeyRangePart) String() string {
	return x.MarshalProtoText()
}
func (x *SplitQueryResponse_ShardPart) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ShardPart { ")
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if len(x.Shards) > 0 {
		sb.WriteString(" shards: [")
		for i, v := range x.Shards {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SplitQueryResponse_ShardPart) String() string {
	return x.MarshalProtoText()
}
func (x *SplitQueryResponse_Part) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Part { ")
	if x.Query != nil {
		sb.WriteString(" query: ")
		sb.WriteString(x.Query.MarshalProtoText())
	}
	if x.KeyRangePart != nil {
		sb.WriteString(" key_range_part: ")
		sb.WriteString(x.KeyRangePart.MarshalProtoText())
	}
	if x.ShardPart != nil {
		sb.WriteString(" shard_part: ")
		sb.WriteString(x.ShardPart.MarshalProtoText())
	}
	if x.Size != 0 {
		sb.WriteString(" size: ")
		sb.WriteString(strconv.FormatInt(int64(x.Size), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SplitQueryResponse_Part) String() string {
	return x.MarshalProtoText()
}
func (x *SplitQueryResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("SplitQueryResponse { ")
	if len(x.Splits) > 0 {
		sb.WriteString(" splits: [")
		for i, v := range x.Splits {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SplitQueryResponse) String() string {
	return x.MarshalProtoText()
}
func (x *GetSrvKeyspaceRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("GetSrvKeyspaceRequest { ")
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *GetSrvKeyspaceRequest) String() string {
	return x.MarshalProtoText()
}
func (x *GetSrvKeyspaceResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("GetSrvKeyspaceResponse { ")
	if x.SrvKeyspace != nil {
		sb.WriteString(" srv_keyspace: ")
		sb.WriteString(x.SrvKeyspace.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *GetSrvKeyspaceResponse) String() string {
	return x.MarshalProtoText()
}
func (x *VStreamRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("VStreamRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.Vgtid != nil {
		sb.WriteString(" vgtid: ")
		sb.WriteString(x.Vgtid.MarshalProtoText())
	}
	if x.Filter != nil {
		sb.WriteString(" filter: ")
		sb.WriteString(x.Filter.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *VStreamRequest) String() string {
	return x.MarshalProtoText()
}
func (x *VStreamResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("VStreamResponse { ")
	if len(x.Events) > 0 {
		sb.WriteString(" events: [")
		for i, v := range x.Events {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *VStreamResponse) String() string {
	return x.MarshalProtoText()
}
func (x *UpdateStreamRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("UpdateStreamRequest { ")
	if x.CallerId != nil {
		sb.WriteString(" caller_id: ")
		sb.WriteString(x.CallerId.MarshalProtoText())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.Shard != "" {
		sb.WriteString(" shard: ")
		sb.WriteString(strconv.Quote(x.Shard))
	}
	if x.KeyRange != nil {
		sb.WriteString(" key_range: ")
		sb.WriteString(x.KeyRange.MarshalProtoText())
	}
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(topodata.TabletType(x.TabletType).String())
	}
	if x.Timestamp != 0 {
		sb.WriteString(" timestamp: ")
		sb.WriteString(strconv.FormatInt(int64(x.Timestamp), 10))
	}
	if x.Event != nil {
		sb.WriteString(" event: ")
		sb.WriteString(x.Event.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *UpdateStreamRequest) String() string {
	return x.MarshalProtoText()
}
func (x *UpdateStreamResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("UpdateStreamResponse { ")
	if x.Event != nil {
		sb.WriteString(" event: ")
		sb.WriteString(x.Event.MarshalProtoText())
	}
	if x.ResumeTimestamp != 0 {
		sb.WriteString(" resume_timestamp: ")
		sb.WriteString(strconv.FormatInt(int64(x.ResumeTimestamp), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *UpdateStreamResponse) String() string {
	return x.MarshalProtoText()
}
func (m *Session_ShardSession) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session_ShardSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session_ShardSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			m.TransactionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InTransaction = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardSessions = append(m.ShardSessions, &Session_ShardSession{})
			if err := m.ShardSessions[len(m.ShardSessions)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleDb", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SingleDb = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autocommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autocommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionMode", wireType)
			}
			m.TransactionMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionMode |= TransactionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warnings = append(m.Warnings, &query.QueryWarning{})
			if err := m.Warnings[len(m.Warnings)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreSessions = append(m.PreSessions, &Session_ShardSession{})
			if err := m.PreSessions[len(m.PreSessions)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostSessions = append(m.PostSessions, &Session_ShardSession{})
			if err := m.PostSessions[len(m.PostSessions)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteShardsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteShardsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyspaceIdsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceIds = append(m.KeyspaceIds, make([]byte, postIndex-iNdEx))
			copy(m.KeyspaceIds[len(m.KeyspaceIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyspaceIdsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyRangesRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &topodata.KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyRangesResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteEntityIdsRequest_EntityId) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteEntityIdsRequest_EntityId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteEntityIdsRequest_EntityId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= query.Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceId = append(m.KeyspaceId[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceId == nil {
				m.KeyspaceId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteEntityIdsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteEntityIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteEntityIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityKeyspaceIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityKeyspaceIds = append(m.EntityKeyspaceIds, &ExecuteEntityIdsRequest_EntityId{})
			if err := m.EntityKeyspaceIds[len(m.EntityKeyspaceIds)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteEntityIdsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteEntityIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteEntityIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &query.BoundQuery{})
			if err := m.Queries[len(m.Queries)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &query.ResultWithError{})
			if err := m.Results[len(m.Results)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoundShardQuery) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundShardQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundShardQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchShardsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &BoundShardQuery{})
			if err := m.Queries[len(m.Queries)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchShardsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &query.QueryResult{})
			if err := m.Results[len(m.Results)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoundKeyspaceIdQuery) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundKeyspaceIdQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundKeyspaceIdQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceIds = append(m.KeyspaceIds, make([]byte, postIndex-iNdEx))
			copy(m.KeyspaceIds[len(m.KeyspaceIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchKeyspaceIdsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &BoundKeyspaceIdQuery{})
			if err := m.Queries[len(m.Queries)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchKeyspaceIdsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &query.QueryResult{})
			if err := m.Results[len(m.Results)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteShardsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteShardsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyspaceIdsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceIds = append(m.KeyspaceIds, make([]byte, postIndex-iNdEx))
			copy(m.KeyspaceIds[len(m.KeyspaceIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyspaceIdsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyRangesRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &topodata.KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyRangesResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleDb", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SingleDb = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atomic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atomic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveTransactionRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageStreamRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageAckRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageAckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageAckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, &query.Value{})
			if err := m.Ids[len(m.Ids)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdKeyspaceId) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdKeyspaceId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdKeyspaceId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &query.Value{}
			}
			if err := m.Id.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceId = append(m.KeyspaceId[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceId == nil {
				m.KeyspaceId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageAckKeyspaceIdsRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageAckKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageAckKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdKeyspaceIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdKeyspaceIds = append(m.IdKeyspaceIds, &IdKeyspaceId{})
			if err := m.IdKeyspaceIds[len(m.IdKeyspaceIds)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveTransactionResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitColumn = append(m.SplitColumn, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitCount", wireType)
			}
			m.SplitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRowsPerQueryPart", wireType)
			}
			m.NumRowsPerQueryPart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRowsPerQueryPart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= query.SplitQueryRequest_Algorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSplitQueryV2", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSplitQueryV2 = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse_KeyRangePart) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitQueryResponse_KeyRangePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitQueryResponse_KeyRangePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &topodata.KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse_ShardPart) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitQueryResponse_ShardPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitQueryResponse_ShardPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse_Part) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitQueryResponse_Part: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitQueryResponse_Part: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRangePart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRangePart == nil {
				m.KeyRangePart = &SplitQueryResponse_KeyRangePart{}
			}
			if err := m.KeyRangePart.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardPart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardPart == nil {
				m.ShardPart = &SplitQueryResponse_ShardPart{}
			}
			if err := m.ShardPart.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Splits = append(m.Splits, &SplitQueryResponse_Part{})
			if err := m.Splits[len(m.Splits)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSrvKeyspaceRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSrvKeyspaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSrvKeyspaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSrvKeyspaceResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSrvKeyspaceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSrvKeyspaceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvKeyspace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrvKeyspace == nil {
				m.SrvKeyspace = &topodata.SrvKeyspace{}
			}
			if err := m.SrvKeyspace.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vgtid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vgtid == nil {
				m.Vgtid = &binlogdata.VGtid{}
			}
			if err := m.Vgtid.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &binlogdata.Filter{}
			}
			if err := m.Filter.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &binlogdata.VEvent{})
			if err := m.Events[len(m.Events)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStreamRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &query.EventToken{}
			}
			if err := m.Event.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStreamResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &query.StreamEvent{}
			}
			if err := m.Event.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeTimestamp", wireType)
			}
			m.ResumeTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResumeTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
