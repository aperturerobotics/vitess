// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.6.1
// source: github.com/dolthub/vitess/proto/dolthub/vt/topodata.proto

package topodata

import (
	base64 "encoding/base64"
	fmt "fmt"
	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	json "github.com/aperturerobotics/protobuf-go-lite/json"
	vttime "github.com/dolthub/vitess/go/vt/proto/vttime"
	io "io"
	strconv "strconv"
	strings "strings"
)

//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains the Vitess topology related data structures.
// Very few of these structures are exchanged over the wire (only
// TabletType and KeyRange), but they are all used by the topology
// service.

// KeyspaceType describes the type of the keyspace
type KeyspaceType int32

const (
	// NORMAL is the default value
	KeyspaceType_NORMAL KeyspaceType = 0
	// SNAPSHOT is when we are creating a snapshot keyspace
	KeyspaceType_SNAPSHOT KeyspaceType = 1
)

// Enum value maps for KeyspaceType.
var (
	KeyspaceType_name = map[int32]string{
		0: "NORMAL",
		1: "SNAPSHOT",
	}
	KeyspaceType_value = map[string]int32{
		"NORMAL":   0,
		"SNAPSHOT": 1,
	}
)

func (x KeyspaceType) Enum() *KeyspaceType {
	p := new(KeyspaceType)
	*p = x
	return p
}

func (x KeyspaceType) String() string {
	name, valid := KeyspaceType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// KeyspaceIdType describes the type of the sharding key for a
// range-based sharded keyspace.
type KeyspaceIdType int32

const (
	// UNSET is the default value, when range-based sharding is not used.
	KeyspaceIdType_UNSET KeyspaceIdType = 0
	// UINT64 is when uint64 value is used.
	// This is represented as 'unsigned bigint' in mysql
	KeyspaceIdType_UINT64 KeyspaceIdType = 1
	// BYTES is when an array of bytes is used.
	// This is represented as 'varbinary' in mysql
	KeyspaceIdType_BYTES KeyspaceIdType = 2
)

// Enum value maps for KeyspaceIdType.
var (
	KeyspaceIdType_name = map[int32]string{
		0: "UNSET",
		1: "UINT64",
		2: "BYTES",
	}
	KeyspaceIdType_value = map[string]int32{
		"UNSET":  0,
		"UINT64": 1,
		"BYTES":  2,
	}
)

func (x KeyspaceIdType) Enum() *KeyspaceIdType {
	p := new(KeyspaceIdType)
	*p = x
	return p
}

func (x KeyspaceIdType) String() string {
	name, valid := KeyspaceIdType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// TabletType represents the type of a given tablet.
type TabletType int32

const (
	// UNKNOWN is not a valid value.
	TabletType_UNKNOWN TabletType = 0
	// MASTER is the master server for the shard. Only MASTER allows DMLs.
	TabletType_MASTER TabletType = 1
	// REPLICA is a slave type. It is used to serve live traffic.
	// A REPLICA can be promoted to MASTER. A demoted MASTER will go to REPLICA.
	TabletType_REPLICA TabletType = 2
	// RDONLY (old name) / BATCH (new name) is used to serve traffic for
	// long-running jobs. It is a separate type from REPLICA so
	// long-running queries don't affect web-like traffic.
	TabletType_RDONLY TabletType = 3
	TabletType_BATCH  TabletType = 3
	// SPARE is a type of servers that cannot serve queries, but is available
	// in case an extra server is needed.
	TabletType_SPARE TabletType = 4
	// EXPERIMENTAL is like SPARE, except it can serve queries. This
	// type can be used for usages not planned by Vitess, like online
	// export to another storage engine.
	TabletType_EXPERIMENTAL TabletType = 5
	// BACKUP is the type a server goes to when taking a backup. No queries
	// can be served in BACKUP mode.
	TabletType_BACKUP TabletType = 6
	// RESTORE is the type a server uses when restoring a backup, at
	// startup time.  No queries can be served in RESTORE mode.
	TabletType_RESTORE TabletType = 7
	// DRAINED is the type a server goes into when used by Vitess tools
	// to perform an offline action. It is a serving type (as
	// the tools processes may need to run queries), but it's not used
	// to route queries from Vitess users. In this state,
	// this tablet is dedicated to the process that uses it.
	TabletType_DRAINED TabletType = 8
)

// Enum value maps for TabletType.
var (
	TabletType_name = map[int32]string{
		0: "UNKNOWN",
		1: "MASTER",
		2: "REPLICA",
		3: "RDONLY",
		// Duplicate value: 3: "BATCH",
		4: "SPARE",
		5: "EXPERIMENTAL",
		6: "BACKUP",
		7: "RESTORE",
		8: "DRAINED",
	}
	TabletType_value = map[string]int32{
		"UNKNOWN":      0,
		"MASTER":       1,
		"REPLICA":      2,
		"RDONLY":       3,
		"BATCH":        3,
		"SPARE":        4,
		"EXPERIMENTAL": 5,
		"BACKUP":       6,
		"RESTORE":      7,
		"DRAINED":      8,
	}
)

func (x TabletType) Enum() *TabletType {
	p := new(TabletType)
	*p = x
	return p
}

func (x TabletType) String() string {
	name, valid := TabletType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// KeyRange describes a range of sharding keys, when range-based
// sharding is used.
type KeyRange struct {
	unknownFields []byte
	Start         []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End           []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *KeyRange) Reset() {
	*x = KeyRange{}
}

func (*KeyRange) ProtoMessage() {}

func (x *KeyRange) GetStart() []byte {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *KeyRange) GetEnd() []byte {
	if x != nil {
		return x.End
	}
	return nil
}

// TabletAlias is a globally unique tablet identifier.
type TabletAlias struct {
	unknownFields []byte
	// cell is the cell (or datacenter) the tablet is in
	Cell string `protobuf:"bytes,1,opt,name=cell,proto3" json:"cell,omitempty"`
	// uid is a unique id for this tablet within the shard
	// (this is the MySQL server id as well).
	Uid uint32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (x *TabletAlias) Reset() {
	*x = TabletAlias{}
}

func (*TabletAlias) ProtoMessage() {}

func (x *TabletAlias) GetCell() string {
	if x != nil {
		return x.Cell
	}
	return ""
}

func (x *TabletAlias) GetUid() uint32 {
	if x != nil {
		return x.Uid
	}
	return 0
}

// Tablet represents information about a running instance of vttablet.
type Tablet struct {
	unknownFields []byte
	// alias is the unique name of the tablet.
	Alias *TabletAlias `protobuf:"bytes,1,opt,name=alias,proto3" json:"alias,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. Normally this should include vt and grpc.
	// Going forward, the mysql port will be stored in mysql_port
	// instead of here.
	// For accessing mysql port, use topoproto.MysqlPort to fetch, and
	// topoproto.SetMysqlPort to set. These wrappers will ensure
	// legacy behavior is supported.
	PortMap map[string]int32 `protobuf:"bytes,4,rep,name=port_map,json=portMap,proto3" json:"portMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Keyspace name.
	Keyspace string `protobuf:"bytes,5,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// Shard name. If range based sharding is used, it should match
	// key_range.
	Shard string `protobuf:"bytes,6,opt,name=shard,proto3" json:"shard,omitempty"`
	// If range based sharding is used, range for the tablet's shard.
	KeyRange *KeyRange `protobuf:"bytes,7,opt,name=key_range,json=keyRange,proto3" json:"keyRange,omitempty"`
	// type is the current type of the tablet.
	Type TabletType `protobuf:"varint,8,opt,name=type,proto3" json:"type,omitempty"`
	// It this is set, it is used as the database name instead of the
	// normal "vt_" + keyspace.
	DbNameOverride string `protobuf:"bytes,9,opt,name=db_name_override,json=dbNameOverride,proto3" json:"dbNameOverride,omitempty"`
	// tablet tags
	Tags map[string]string `protobuf:"bytes,10,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// MySQL hostname.
	MysqlHostname string `protobuf:"bytes,12,opt,name=mysql_hostname,json=mysqlHostname,proto3" json:"mysqlHostname,omitempty"`
	// MySQL port. Use topoproto.MysqlPort and topoproto.SetMysqlPort
	// to access this variable. The functions provide support
	// for legacy behavior.
	MysqlPort int32 `protobuf:"varint,13,opt,name=mysql_port,json=mysqlPort,proto3" json:"mysqlPort,omitempty"`
	// master_term_start_time is the time (in UTC) at which the current term of
	// the current tablet began as master. If this tablet is not currently the
	// master, this value is ignored.
	//
	// A new master term begins any time an authoritative decision is communicated
	// about which tablet should be the master, such as via Vitess
	// replication-management commands like PlannedReparentShard,
	// EmergencyReparentShard, and TabletExternallyReparented.
	MasterTermStartTime *vttime.Time `protobuf:"bytes,14,opt,name=master_term_start_time,json=masterTermStartTime,proto3" json:"masterTermStartTime,omitempty"`
}

func (x *Tablet) Reset() {
	*x = Tablet{}
}

func (*Tablet) ProtoMessage() {}

func (x *Tablet) GetAlias() *TabletAlias {
	if x != nil {
		return x.Alias
	}
	return nil
}

func (x *Tablet) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *Tablet) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

func (x *Tablet) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *Tablet) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *Tablet) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *Tablet) GetType() TabletType {
	if x != nil {
		return x.Type
	}
	return TabletType_UNKNOWN
}

func (x *Tablet) GetDbNameOverride() string {
	if x != nil {
		return x.DbNameOverride
	}
	return ""
}

func (x *Tablet) GetTags() map[string]string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *Tablet) GetMysqlHostname() string {
	if x != nil {
		return x.MysqlHostname
	}
	return ""
}

func (x *Tablet) GetMysqlPort() int32 {
	if x != nil {
		return x.MysqlPort
	}
	return 0
}

func (x *Tablet) GetMasterTermStartTime() *vttime.Time {
	if x != nil {
		return x.MasterTermStartTime
	}
	return nil
}

// A Shard contains data about a subset of the data whithin a keyspace.
type Shard struct {
	unknownFields []byte
	// master_alias is the tablet alias of the master for the shard.
	// If it is unset, then there is no master in this shard yet.
	// No lock is necessary to update this field, when for instance
	// TabletExternallyReparented updates this. However, we lock the
	// shard for reparenting operations (InitShardMaster,
	// PlannedReparentShard,EmergencyReparentShard), to guarantee
	// exclusive operation.
	MasterAlias *TabletAlias `protobuf:"bytes,1,opt,name=master_alias,json=masterAlias,proto3" json:"masterAlias,omitempty"`
	// master_term_start_time is the time (in UTC) at which the current term of
	// the master specified in master_alias began.
	//
	// A new master term begins any time an authoritative decision is communicated
	// about which tablet should be the master, such as via Vitess
	// replication-management commands like PlannedReparentShard,
	// EmergencyReparentShard, and TabletExternallyReparented.
	//
	// The master_alias should only ever be changed if the new master's term began
	// at a later time than this. Note that a new term can start for the tablet
	// that is already the master. In that case, the master_term_start_time would
	// be increased without changing the master_alias.
	MasterTermStartTime *vttime.Time `protobuf:"bytes,8,opt,name=master_term_start_time,json=masterTermStartTime,proto3" json:"masterTermStartTime,omitempty"`
	// key_range is the KeyRange for this shard. It can be unset if:
	// - we are not using range-based sharding in this shard.
	// - the shard covers the entire keyrange.
	// This must match the shard name based on our other conventions, but
	// helpful to have it decomposed here.
	// Once set at creation time, it is never changed.
	KeyRange *KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"keyRange,omitempty"`
	// served_types has at most one entry per TabletType
	// This field is in the process of being deprecated in favor of
	// is_master_serving. Keeping for backwards compatibility purposes.
	ServedTypes []*Shard_ServedType `protobuf:"bytes,3,rep,name=served_types,json=servedTypes,proto3" json:"servedTypes,omitempty"`
	// SourceShards is the list of shards we're replicating from,
	// using filtered replication.
	// The keyspace lock is always taken when changing this.
	SourceShards []*Shard_SourceShard `protobuf:"bytes,4,rep,name=source_shards,json=sourceShards,proto3" json:"sourceShards,omitempty"`
	// tablet_controls has at most one entry per TabletType.
	// The keyspace lock is always taken when changing this.
	TabletControls []*Shard_TabletControl `protobuf:"bytes,6,rep,name=tablet_controls,json=tabletControls,proto3" json:"tabletControls,omitempty"`
	// is_master_serving sets whether this shard master is serving traffic or not.
	// The keyspace lock is always taken when changing this.
	IsMasterServing bool `protobuf:"varint,7,opt,name=is_master_serving,json=isMasterServing,proto3" json:"isMasterServing,omitempty"`
}

func (x *Shard) Reset() {
	*x = Shard{}
}

func (*Shard) ProtoMessage() {}

func (x *Shard) GetMasterAlias() *TabletAlias {
	if x != nil {
		return x.MasterAlias
	}
	return nil
}

func (x *Shard) GetMasterTermStartTime() *vttime.Time {
	if x != nil {
		return x.MasterTermStartTime
	}
	return nil
}

func (x *Shard) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *Shard) GetServedTypes() []*Shard_ServedType {
	if x != nil {
		return x.ServedTypes
	}
	return nil
}

func (x *Shard) GetSourceShards() []*Shard_SourceShard {
	if x != nil {
		return x.SourceShards
	}
	return nil
}

func (x *Shard) GetTabletControls() []*Shard_TabletControl {
	if x != nil {
		return x.TabletControls
	}
	return nil
}

func (x *Shard) GetIsMasterServing() bool {
	if x != nil {
		return x.IsMasterServing
	}
	return false
}

// A Keyspace contains data about a keyspace.
type Keyspace struct {
	unknownFields []byte
	// name of the column used for sharding
	// empty if the keyspace is not sharded
	ShardingColumnName string `protobuf:"bytes,1,opt,name=sharding_column_name,json=shardingColumnName,proto3" json:"shardingColumnName,omitempty"`
	// type of the column used for sharding
	// UNSET if the keyspace is not sharded
	ShardingColumnType KeyspaceIdType `protobuf:"varint,2,opt,name=sharding_column_type,json=shardingColumnType,proto3" json:"shardingColumnType,omitempty"`
	// ServedFrom will redirect the appropriate traffic to
	// another keyspace.
	ServedFroms []*Keyspace_ServedFrom `protobuf:"bytes,4,rep,name=served_froms,json=servedFroms,proto3" json:"servedFroms,omitempty"`
	// keyspace_type will determine how this keyspace is treated by
	// vtgate / vschema. Normal keyspaces are routable by
	// any query. Snapshot keyspaces are only accessible
	// by explicit addresssing or by calling "use keyspace" first
	KeyspaceType KeyspaceType `protobuf:"varint,5,opt,name=keyspace_type,json=keyspaceType,proto3" json:"keyspaceType,omitempty"`
	// base_keyspace is the base keyspace from which a snapshot
	// keyspace is created. empty for normal keyspaces
	BaseKeyspace string `protobuf:"bytes,6,opt,name=base_keyspace,json=baseKeyspace,proto3" json:"baseKeyspace,omitempty"`
	// snapshot_time (in UTC) is a property of snapshot
	// keyspaces which tells us what point in time
	// the snapshot is of
	SnapshotTime *vttime.Time `protobuf:"bytes,7,opt,name=snapshot_time,json=snapshotTime,proto3" json:"snapshotTime,omitempty"`
}

func (x *Keyspace) Reset() {
	*x = Keyspace{}
}

func (*Keyspace) ProtoMessage() {}

func (x *Keyspace) GetShardingColumnName() string {
	if x != nil {
		return x.ShardingColumnName
	}
	return ""
}

func (x *Keyspace) GetShardingColumnType() KeyspaceIdType {
	if x != nil {
		return x.ShardingColumnType
	}
	return KeyspaceIdType_UNSET
}

func (x *Keyspace) GetServedFroms() []*Keyspace_ServedFrom {
	if x != nil {
		return x.ServedFroms
	}
	return nil
}

func (x *Keyspace) GetKeyspaceType() KeyspaceType {
	if x != nil {
		return x.KeyspaceType
	}
	return KeyspaceType_NORMAL
}

func (x *Keyspace) GetBaseKeyspace() string {
	if x != nil {
		return x.BaseKeyspace
	}
	return ""
}

func (x *Keyspace) GetSnapshotTime() *vttime.Time {
	if x != nil {
		return x.SnapshotTime
	}
	return nil
}

// ShardReplication describes the MySQL replication relationships
// whithin a cell.
type ShardReplication struct {
	unknownFields []byte
	// Note there can be only one Node in this array
	// for a given tablet.
	Nodes []*ShardReplication_Node `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (x *ShardReplication) Reset() {
	*x = ShardReplication{}
}

func (*ShardReplication) ProtoMessage() {}

func (x *ShardReplication) GetNodes() []*ShardReplication_Node {
	if x != nil {
		return x.Nodes
	}
	return nil
}

// ShardReference is used as a pointer from a SrvKeyspace to a Shard
type ShardReference struct {
	unknownFields []byte
	// Copied from Shard.
	Name     string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	KeyRange *KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"keyRange,omitempty"` // Disable query serving in this shard
}

func (x *ShardReference) Reset() {
	*x = ShardReference{}
}

func (*ShardReference) ProtoMessage() {}

func (x *ShardReference) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ShardReference) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

// ShardTabletControl is used as a pointer from a SrvKeyspace to a Shard
type ShardTabletControl struct {
	unknownFields []byte
	// Copied from Shard.
	Name     string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	KeyRange *KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"keyRange,omitempty"`
	// Disable query serving in this shard
	QueryServiceDisabled bool `protobuf:"varint,3,opt,name=query_service_disabled,json=queryServiceDisabled,proto3" json:"queryServiceDisabled,omitempty"`
}

func (x *ShardTabletControl) Reset() {
	*x = ShardTabletControl{}
}

func (*ShardTabletControl) ProtoMessage() {}

func (x *ShardTabletControl) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ShardTabletControl) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *ShardTabletControl) GetQueryServiceDisabled() bool {
	if x != nil {
		return x.QueryServiceDisabled
	}
	return false
}

// SrvKeyspace is a rollup node for the keyspace itself.
type SrvKeyspace struct {
	unknownFields []byte
	// The partitions this keyspace is serving, per tablet type.
	Partitions []*SrvKeyspace_KeyspacePartition `protobuf:"bytes,1,rep,name=partitions,proto3" json:"partitions,omitempty"`
	// copied from Keyspace
	ShardingColumnName string                    `protobuf:"bytes,2,opt,name=sharding_column_name,json=shardingColumnName,proto3" json:"shardingColumnName,omitempty"`
	ShardingColumnType KeyspaceIdType            `protobuf:"varint,3,opt,name=sharding_column_type,json=shardingColumnType,proto3" json:"shardingColumnType,omitempty"`
	ServedFrom         []*SrvKeyspace_ServedFrom `protobuf:"bytes,4,rep,name=served_from,json=servedFrom,proto3" json:"servedFrom,omitempty"`
}

func (x *SrvKeyspace) Reset() {
	*x = SrvKeyspace{}
}

func (*SrvKeyspace) ProtoMessage() {}

func (x *SrvKeyspace) GetPartitions() []*SrvKeyspace_KeyspacePartition {
	if x != nil {
		return x.Partitions
	}
	return nil
}

func (x *SrvKeyspace) GetShardingColumnName() string {
	if x != nil {
		return x.ShardingColumnName
	}
	return ""
}

func (x *SrvKeyspace) GetShardingColumnType() KeyspaceIdType {
	if x != nil {
		return x.ShardingColumnType
	}
	return KeyspaceIdType_UNSET
}

func (x *SrvKeyspace) GetServedFrom() []*SrvKeyspace_ServedFrom {
	if x != nil {
		return x.ServedFrom
	}
	return nil
}

// CellInfo contains information about a cell. CellInfo objects are
// stored in the global topology server, and describe how to reach
// local topology servers.
type CellInfo struct {
	unknownFields []byte
	// ServerAddress contains the address of the server for the cell.
	// The syntax of this field is topology implementation specific.
	// For instance, for Zookeeper, it is a comma-separated list of
	// server addresses.
	ServerAddress string `protobuf:"bytes,1,opt,name=server_address,json=serverAddress,proto3" json:"serverAddress,omitempty"`
	// Root is the path to store data in. It is only used when talking
	// to server_address.
	Root string `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (x *CellInfo) Reset() {
	*x = CellInfo{}
}

func (*CellInfo) ProtoMessage() {}

func (x *CellInfo) GetServerAddress() string {
	if x != nil {
		return x.ServerAddress
	}
	return ""
}

func (x *CellInfo) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

// CellsAlias
type CellsAlias struct {
	unknownFields []byte
	// Cells that map to this alias
	Cells []string `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
}

func (x *CellsAlias) Reset() {
	*x = CellsAlias{}
}

func (*CellsAlias) ProtoMessage() {}

func (x *CellsAlias) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

type Tablet_PortMapEntry struct {
	unknownFields []byte
	Key           string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         int32  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Tablet_PortMapEntry) Reset() {
	*x = Tablet_PortMapEntry{}
}

func (*Tablet_PortMapEntry) ProtoMessage() {}

func (x *Tablet_PortMapEntry) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Tablet_PortMapEntry) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type Tablet_TagsEntry struct {
	unknownFields []byte
	Key           string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Tablet_TagsEntry) Reset() {
	*x = Tablet_TagsEntry{}
}

func (*Tablet_TagsEntry) ProtoMessage() {}

func (x *Tablet_TagsEntry) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Tablet_TagsEntry) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// ServedType is an entry in the served_types
type Shard_ServedType struct {
	unknownFields []byte
	TabletType    TabletType `protobuf:"varint,1,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	Cells         []string   `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
}

func (x *Shard_ServedType) Reset() {
	*x = Shard_ServedType{}
}

func (*Shard_ServedType) ProtoMessage() {}

func (x *Shard_ServedType) GetTabletType() TabletType {
	if x != nil {
		return x.TabletType
	}
	return TabletType_UNKNOWN
}

func (x *Shard_ServedType) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

// SourceShard represents a data source for filtered replication
// across shards. When this is used in a destination shard, the master
// of that shard will run filtered replication.
type Shard_SourceShard struct {
	unknownFields []byte
	// Uid is the unique ID for this SourceShard object.
	Uid uint32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// the source keyspace
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// the source shard
	Shard string `protobuf:"bytes,3,opt,name=shard,proto3" json:"shard,omitempty"`
	// the source shard keyrange
	KeyRange *KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"keyRange,omitempty"`
	// the source table list to replicate
	Tables []string `protobuf:"bytes,5,rep,name=tables,proto3" json:"tables,omitempty"`
}

func (x *Shard_SourceShard) Reset() {
	*x = Shard_SourceShard{}
}

func (*Shard_SourceShard) ProtoMessage() {}

func (x *Shard_SourceShard) GetUid() uint32 {
	if x != nil {
		return x.Uid
	}
	return 0
}

func (x *Shard_SourceShard) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *Shard_SourceShard) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *Shard_SourceShard) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *Shard_SourceShard) GetTables() []string {
	if x != nil {
		return x.Tables
	}
	return nil
}

// TabletControl controls tablet's behavior
type Shard_TabletControl struct {
	unknownFields []byte
	// which tablet type is affected
	TabletType        TabletType `protobuf:"varint,1,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	Cells             []string   `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
	BlacklistedTables []string   `protobuf:"bytes,4,rep,name=blacklisted_tables,json=blacklistedTables,proto3" json:"blacklistedTables,omitempty"`
	// frozen is set if we've started failing over traffic for
	// the master. If set, this record should not be removed.
	Frozen bool `protobuf:"varint,5,opt,name=frozen,proto3" json:"frozen,omitempty"`
}

func (x *Shard_TabletControl) Reset() {
	*x = Shard_TabletControl{}
}

func (*Shard_TabletControl) ProtoMessage() {}

func (x *Shard_TabletControl) GetTabletType() TabletType {
	if x != nil {
		return x.TabletType
	}
	return TabletType_UNKNOWN
}

func (x *Shard_TabletControl) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

func (x *Shard_TabletControl) GetBlacklistedTables() []string {
	if x != nil {
		return x.BlacklistedTables
	}
	return nil
}

func (x *Shard_TabletControl) GetFrozen() bool {
	if x != nil {
		return x.Frozen
	}
	return false
}

// ServedFrom indicates a relationship between a TabletType and the
// keyspace name that's serving it.
type Keyspace_ServedFrom struct {
	unknownFields []byte
	// the tablet type (key for the map)
	TabletType TabletType `protobuf:"varint,1,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// the cells to limit this to
	Cells []string `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
	// the keyspace name that's serving it
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
}

func (x *Keyspace_ServedFrom) Reset() {
	*x = Keyspace_ServedFrom{}
}

func (*Keyspace_ServedFrom) ProtoMessage() {}

func (x *Keyspace_ServedFrom) GetTabletType() TabletType {
	if x != nil {
		return x.TabletType
	}
	return TabletType_UNKNOWN
}

func (x *Keyspace_ServedFrom) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

func (x *Keyspace_ServedFrom) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

// Node describes a tablet instance within the cell
type ShardReplication_Node struct {
	unknownFields []byte
	TabletAlias   *TabletAlias `protobuf:"bytes,1,opt,name=tablet_alias,json=tabletAlias,proto3" json:"tabletAlias,omitempty"`
}

func (x *ShardReplication_Node) Reset() {
	*x = ShardReplication_Node{}
}

func (*ShardReplication_Node) ProtoMessage() {}

func (x *ShardReplication_Node) GetTabletAlias() *TabletAlias {
	if x != nil {
		return x.TabletAlias
	}
	return nil
}

type SrvKeyspace_KeyspacePartition struct {
	unknownFields []byte
	// The type this partition applies to.
	ServedType TabletType `protobuf:"varint,1,opt,name=served_type,json=servedType,proto3" json:"servedType,omitempty"`
	// List of non-overlapping continuous shards sorted by range.
	ShardReferences []*ShardReference `protobuf:"bytes,2,rep,name=shard_references,json=shardReferences,proto3" json:"shardReferences,omitempty"`
	// List of shard tablet controls
	ShardTabletControls []*ShardTabletControl `protobuf:"bytes,3,rep,name=shard_tablet_controls,json=shardTabletControls,proto3" json:"shardTabletControls,omitempty"`
}

func (x *SrvKeyspace_KeyspacePartition) Reset() {
	*x = SrvKeyspace_KeyspacePartition{}
}

func (*SrvKeyspace_KeyspacePartition) ProtoMessage() {}

func (x *SrvKeyspace_KeyspacePartition) GetServedType() TabletType {
	if x != nil {
		return x.ServedType
	}
	return TabletType_UNKNOWN
}

func (x *SrvKeyspace_KeyspacePartition) GetShardReferences() []*ShardReference {
	if x != nil {
		return x.ShardReferences
	}
	return nil
}

func (x *SrvKeyspace_KeyspacePartition) GetShardTabletControls() []*ShardTabletControl {
	if x != nil {
		return x.ShardTabletControls
	}
	return nil
}

// ServedFrom indicates a relationship between a TabletType and the
// keyspace name that's serving it.
type SrvKeyspace_ServedFrom struct {
	unknownFields []byte
	// the tablet type
	TabletType TabletType `protobuf:"varint,1,opt,name=tablet_type,json=tabletType,proto3" json:"tabletType,omitempty"`
	// the keyspace name that's serving it
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
}

func (x *SrvKeyspace_ServedFrom) Reset() {
	*x = SrvKeyspace_ServedFrom{}
}

func (*SrvKeyspace_ServedFrom) ProtoMessage() {}

func (x *SrvKeyspace_ServedFrom) GetTabletType() TabletType {
	if x != nil {
		return x.TabletType
	}
	return TabletType_UNKNOWN
}

func (x *SrvKeyspace_ServedFrom) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (m *KeyRange) CloneVT() *KeyRange {
	if m == nil {
		return (*KeyRange)(nil)
	}
	r := new(KeyRange)
	if rhs := m.Start; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Start = tmpBytes
	}
	if rhs := m.End; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.End = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *KeyRange) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *TabletAlias) CloneVT() *TabletAlias {
	if m == nil {
		return (*TabletAlias)(nil)
	}
	r := new(TabletAlias)
	r.Cell = m.Cell
	r.Uid = m.Uid
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TabletAlias) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Tablet) CloneVT() *Tablet {
	if m == nil {
		return (*Tablet)(nil)
	}
	r := new(Tablet)
	r.Alias = m.Alias.CloneVT()
	r.Hostname = m.Hostname
	r.Keyspace = m.Keyspace
	r.Shard = m.Shard
	r.KeyRange = m.KeyRange.CloneVT()
	r.Type = m.Type
	r.DbNameOverride = m.DbNameOverride
	r.MysqlHostname = m.MysqlHostname
	r.MysqlPort = m.MysqlPort
	if rhs := m.PortMap; rhs != nil {
		tmpContainer := make(map[string]int32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.PortMap = tmpContainer
	}
	if rhs := m.Tags; rhs != nil {
		tmpContainer := make(map[string]string, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.Tags = tmpContainer
	}
	if rhs := m.MasterTermStartTime; rhs != nil {
		r.MasterTermStartTime = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Tablet) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Shard_ServedType) CloneVT() *Shard_ServedType {
	if m == nil {
		return (*Shard_ServedType)(nil)
	}
	r := new(Shard_ServedType)
	r.TabletType = m.TabletType
	if rhs := m.Cells; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Cells = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Shard_ServedType) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Shard_SourceShard) CloneVT() *Shard_SourceShard {
	if m == nil {
		return (*Shard_SourceShard)(nil)
	}
	r := new(Shard_SourceShard)
	r.Uid = m.Uid
	r.Keyspace = m.Keyspace
	r.Shard = m.Shard
	r.KeyRange = m.KeyRange.CloneVT()
	if rhs := m.Tables; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Tables = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Shard_SourceShard) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Shard_TabletControl) CloneVT() *Shard_TabletControl {
	if m == nil {
		return (*Shard_TabletControl)(nil)
	}
	r := new(Shard_TabletControl)
	r.TabletType = m.TabletType
	r.Frozen = m.Frozen
	if rhs := m.Cells; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Cells = tmpContainer
	}
	if rhs := m.BlacklistedTables; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.BlacklistedTables = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Shard_TabletControl) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Shard) CloneVT() *Shard {
	if m == nil {
		return (*Shard)(nil)
	}
	r := new(Shard)
	r.MasterAlias = m.MasterAlias.CloneVT()
	r.KeyRange = m.KeyRange.CloneVT()
	r.IsMasterServing = m.IsMasterServing
	if rhs := m.MasterTermStartTime; rhs != nil {
		r.MasterTermStartTime = rhs.CloneVT()
	}
	if rhs := m.ServedTypes; rhs != nil {
		tmpContainer := make([]*Shard_ServedType, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ServedTypes = tmpContainer
	}
	if rhs := m.SourceShards; rhs != nil {
		tmpContainer := make([]*Shard_SourceShard, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.SourceShards = tmpContainer
	}
	if rhs := m.TabletControls; rhs != nil {
		tmpContainer := make([]*Shard_TabletControl, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.TabletControls = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Shard) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Keyspace_ServedFrom) CloneVT() *Keyspace_ServedFrom {
	if m == nil {
		return (*Keyspace_ServedFrom)(nil)
	}
	r := new(Keyspace_ServedFrom)
	r.TabletType = m.TabletType
	r.Keyspace = m.Keyspace
	if rhs := m.Cells; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Cells = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Keyspace_ServedFrom) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Keyspace) CloneVT() *Keyspace {
	if m == nil {
		return (*Keyspace)(nil)
	}
	r := new(Keyspace)
	r.ShardingColumnName = m.ShardingColumnName
	r.ShardingColumnType = m.ShardingColumnType
	r.KeyspaceType = m.KeyspaceType
	r.BaseKeyspace = m.BaseKeyspace
	if rhs := m.ServedFroms; rhs != nil {
		tmpContainer := make([]*Keyspace_ServedFrom, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ServedFroms = tmpContainer
	}
	if rhs := m.SnapshotTime; rhs != nil {
		r.SnapshotTime = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Keyspace) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ShardReplication_Node) CloneVT() *ShardReplication_Node {
	if m == nil {
		return (*ShardReplication_Node)(nil)
	}
	r := new(ShardReplication_Node)
	r.TabletAlias = m.TabletAlias.CloneVT()
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ShardReplication_Node) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ShardReplication) CloneVT() *ShardReplication {
	if m == nil {
		return (*ShardReplication)(nil)
	}
	r := new(ShardReplication)
	if rhs := m.Nodes; rhs != nil {
		tmpContainer := make([]*ShardReplication_Node, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Nodes = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ShardReplication) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ShardReference) CloneVT() *ShardReference {
	if m == nil {
		return (*ShardReference)(nil)
	}
	r := new(ShardReference)
	r.Name = m.Name
	r.KeyRange = m.KeyRange.CloneVT()
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ShardReference) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ShardTabletControl) CloneVT() *ShardTabletControl {
	if m == nil {
		return (*ShardTabletControl)(nil)
	}
	r := new(ShardTabletControl)
	r.Name = m.Name
	r.KeyRange = m.KeyRange.CloneVT()
	r.QueryServiceDisabled = m.QueryServiceDisabled
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ShardTabletControl) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SrvKeyspace_KeyspacePartition) CloneVT() *SrvKeyspace_KeyspacePartition {
	if m == nil {
		return (*SrvKeyspace_KeyspacePartition)(nil)
	}
	r := new(SrvKeyspace_KeyspacePartition)
	r.ServedType = m.ServedType
	if rhs := m.ShardReferences; rhs != nil {
		tmpContainer := make([]*ShardReference, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ShardReferences = tmpContainer
	}
	if rhs := m.ShardTabletControls; rhs != nil {
		tmpContainer := make([]*ShardTabletControl, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ShardTabletControls = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SrvKeyspace_KeyspacePartition) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SrvKeyspace_ServedFrom) CloneVT() *SrvKeyspace_ServedFrom {
	if m == nil {
		return (*SrvKeyspace_ServedFrom)(nil)
	}
	r := new(SrvKeyspace_ServedFrom)
	r.TabletType = m.TabletType
	r.Keyspace = m.Keyspace
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SrvKeyspace_ServedFrom) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SrvKeyspace) CloneVT() *SrvKeyspace {
	if m == nil {
		return (*SrvKeyspace)(nil)
	}
	r := new(SrvKeyspace)
	r.ShardingColumnName = m.ShardingColumnName
	r.ShardingColumnType = m.ShardingColumnType
	if rhs := m.Partitions; rhs != nil {
		tmpContainer := make([]*SrvKeyspace_KeyspacePartition, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Partitions = tmpContainer
	}
	if rhs := m.ServedFrom; rhs != nil {
		tmpContainer := make([]*SrvKeyspace_ServedFrom, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ServedFrom = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SrvKeyspace) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *CellInfo) CloneVT() *CellInfo {
	if m == nil {
		return (*CellInfo)(nil)
	}
	r := new(CellInfo)
	r.ServerAddress = m.ServerAddress
	r.Root = m.Root
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *CellInfo) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *CellsAlias) CloneVT() *CellsAlias {
	if m == nil {
		return (*CellsAlias)(nil)
	}
	r := new(CellsAlias)
	if rhs := m.Cells; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Cells = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *CellsAlias) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *KeyRange) EqualVT(that *KeyRange) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if string(this.Start) != string(that.Start) {
		return false
	}
	if string(this.End) != string(that.End) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *KeyRange) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*KeyRange)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TabletAlias) EqualVT(that *TabletAlias) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Cell != that.Cell {
		return false
	}
	if this.Uid != that.Uid {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TabletAlias) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*TabletAlias)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Tablet) EqualVT(that *Tablet) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Alias.EqualVT(that.Alias) {
		return false
	}
	if this.Hostname != that.Hostname {
		return false
	}
	if len(this.PortMap) != len(that.PortMap) {
		return false
	}
	for i, vx := range this.PortMap {
		vy, ok := that.PortMap[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if this.Shard != that.Shard {
		return false
	}
	if !this.KeyRange.EqualVT(that.KeyRange) {
		return false
	}
	if this.Type != that.Type {
		return false
	}
	if this.DbNameOverride != that.DbNameOverride {
		return false
	}
	if len(this.Tags) != len(that.Tags) {
		return false
	}
	for i, vx := range this.Tags {
		vy, ok := that.Tags[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if this.MysqlHostname != that.MysqlHostname {
		return false
	}
	if this.MysqlPort != that.MysqlPort {
		return false
	}
	if !this.MasterTermStartTime.EqualVT(that.MasterTermStartTime) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Tablet) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Tablet)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Shard_ServedType) EqualVT(that *Shard_ServedType) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if len(this.Cells) != len(that.Cells) {
		return false
	}
	for i, vx := range this.Cells {
		vy := that.Cells[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Shard_ServedType) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Shard_ServedType)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Shard_SourceShard) EqualVT(that *Shard_SourceShard) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Uid != that.Uid {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	if this.Shard != that.Shard {
		return false
	}
	if !this.KeyRange.EqualVT(that.KeyRange) {
		return false
	}
	if len(this.Tables) != len(that.Tables) {
		return false
	}
	for i, vx := range this.Tables {
		vy := that.Tables[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Shard_SourceShard) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Shard_SourceShard)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Shard_TabletControl) EqualVT(that *Shard_TabletControl) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if len(this.Cells) != len(that.Cells) {
		return false
	}
	for i, vx := range this.Cells {
		vy := that.Cells[i]
		if vx != vy {
			return false
		}
	}
	if len(this.BlacklistedTables) != len(that.BlacklistedTables) {
		return false
	}
	for i, vx := range this.BlacklistedTables {
		vy := that.BlacklistedTables[i]
		if vx != vy {
			return false
		}
	}
	if this.Frozen != that.Frozen {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Shard_TabletControl) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Shard_TabletControl)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Shard) EqualVT(that *Shard) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.MasterAlias.EqualVT(that.MasterAlias) {
		return false
	}
	if !this.KeyRange.EqualVT(that.KeyRange) {
		return false
	}
	if len(this.ServedTypes) != len(that.ServedTypes) {
		return false
	}
	for i, vx := range this.ServedTypes {
		vy := that.ServedTypes[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Shard_ServedType{}
			}
			if q == nil {
				q = &Shard_ServedType{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.SourceShards) != len(that.SourceShards) {
		return false
	}
	for i, vx := range this.SourceShards {
		vy := that.SourceShards[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Shard_SourceShard{}
			}
			if q == nil {
				q = &Shard_SourceShard{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.TabletControls) != len(that.TabletControls) {
		return false
	}
	for i, vx := range this.TabletControls {
		vy := that.TabletControls[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Shard_TabletControl{}
			}
			if q == nil {
				q = &Shard_TabletControl{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.IsMasterServing != that.IsMasterServing {
		return false
	}
	if !this.MasterTermStartTime.EqualVT(that.MasterTermStartTime) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Shard) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Shard)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Keyspace_ServedFrom) EqualVT(that *Keyspace_ServedFrom) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if len(this.Cells) != len(that.Cells) {
		return false
	}
	for i, vx := range this.Cells {
		vy := that.Cells[i]
		if vx != vy {
			return false
		}
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Keyspace_ServedFrom) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Keyspace_ServedFrom)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Keyspace) EqualVT(that *Keyspace) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.ShardingColumnName != that.ShardingColumnName {
		return false
	}
	if this.ShardingColumnType != that.ShardingColumnType {
		return false
	}
	if len(this.ServedFroms) != len(that.ServedFroms) {
		return false
	}
	for i, vx := range this.ServedFroms {
		vy := that.ServedFroms[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Keyspace_ServedFrom{}
			}
			if q == nil {
				q = &Keyspace_ServedFrom{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.KeyspaceType != that.KeyspaceType {
		return false
	}
	if this.BaseKeyspace != that.BaseKeyspace {
		return false
	}
	if !this.SnapshotTime.EqualVT(that.SnapshotTime) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Keyspace) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Keyspace)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ShardReplication_Node) EqualVT(that *ShardReplication_Node) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.TabletAlias.EqualVT(that.TabletAlias) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ShardReplication_Node) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ShardReplication_Node)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ShardReplication) EqualVT(that *ShardReplication) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Nodes) != len(that.Nodes) {
		return false
	}
	for i, vx := range this.Nodes {
		vy := that.Nodes[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ShardReplication_Node{}
			}
			if q == nil {
				q = &ShardReplication_Node{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ShardReplication) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ShardReplication)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ShardReference) EqualVT(that *ShardReference) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Name != that.Name {
		return false
	}
	if !this.KeyRange.EqualVT(that.KeyRange) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ShardReference) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ShardReference)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ShardTabletControl) EqualVT(that *ShardTabletControl) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Name != that.Name {
		return false
	}
	if !this.KeyRange.EqualVT(that.KeyRange) {
		return false
	}
	if this.QueryServiceDisabled != that.QueryServiceDisabled {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ShardTabletControl) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ShardTabletControl)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SrvKeyspace_KeyspacePartition) EqualVT(that *SrvKeyspace_KeyspacePartition) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.ServedType != that.ServedType {
		return false
	}
	if len(this.ShardReferences) != len(that.ShardReferences) {
		return false
	}
	for i, vx := range this.ShardReferences {
		vy := that.ShardReferences[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ShardReference{}
			}
			if q == nil {
				q = &ShardReference{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.ShardTabletControls) != len(that.ShardTabletControls) {
		return false
	}
	for i, vx := range this.ShardTabletControls {
		vy := that.ShardTabletControls[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ShardTabletControl{}
			}
			if q == nil {
				q = &ShardTabletControl{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SrvKeyspace_KeyspacePartition) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SrvKeyspace_KeyspacePartition)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SrvKeyspace_ServedFrom) EqualVT(that *SrvKeyspace_ServedFrom) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.TabletType != that.TabletType {
		return false
	}
	if this.Keyspace != that.Keyspace {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SrvKeyspace_ServedFrom) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SrvKeyspace_ServedFrom)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SrvKeyspace) EqualVT(that *SrvKeyspace) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Partitions) != len(that.Partitions) {
		return false
	}
	for i, vx := range this.Partitions {
		vy := that.Partitions[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &SrvKeyspace_KeyspacePartition{}
			}
			if q == nil {
				q = &SrvKeyspace_KeyspacePartition{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.ShardingColumnName != that.ShardingColumnName {
		return false
	}
	if this.ShardingColumnType != that.ShardingColumnType {
		return false
	}
	if len(this.ServedFrom) != len(that.ServedFrom) {
		return false
	}
	for i, vx := range this.ServedFrom {
		vy := that.ServedFrom[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &SrvKeyspace_ServedFrom{}
			}
			if q == nil {
				q = &SrvKeyspace_ServedFrom{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SrvKeyspace) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SrvKeyspace)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *CellInfo) EqualVT(that *CellInfo) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.ServerAddress != that.ServerAddress {
		return false
	}
	if this.Root != that.Root {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *CellInfo) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*CellInfo)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *CellsAlias) EqualVT(that *CellsAlias) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Cells) != len(that.Cells) {
		return false
	}
	for i, vx := range this.Cells {
		vy := that.Cells[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *CellsAlias) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*CellsAlias)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// MarshalProtoJSON marshals the KeyspaceType to JSON.
func (x KeyspaceType) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), KeyspaceType_name)
}

// MarshalText marshals the KeyspaceType to text.
func (x KeyspaceType) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), KeyspaceType_name)), nil
}

// MarshalJSON marshals the KeyspaceType to JSON.
func (x KeyspaceType) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the KeyspaceType from JSON.
func (x *KeyspaceType) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(KeyspaceType_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read KeyspaceType enum: %v", err)
		return
	}
	*x = KeyspaceType(v)
}

// UnmarshalText unmarshals the KeyspaceType from text.
func (x *KeyspaceType) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), KeyspaceType_value)
	if err != nil {
		return err
	}
	*x = KeyspaceType(i)
	return nil
}

// UnmarshalJSON unmarshals the KeyspaceType from JSON.
func (x *KeyspaceType) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the KeyspaceIdType to JSON.
func (x KeyspaceIdType) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), KeyspaceIdType_name)
}

// MarshalText marshals the KeyspaceIdType to text.
func (x KeyspaceIdType) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), KeyspaceIdType_name)), nil
}

// MarshalJSON marshals the KeyspaceIdType to JSON.
func (x KeyspaceIdType) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the KeyspaceIdType from JSON.
func (x *KeyspaceIdType) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(KeyspaceIdType_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read KeyspaceIdType enum: %v", err)
		return
	}
	*x = KeyspaceIdType(v)
}

// UnmarshalText unmarshals the KeyspaceIdType from text.
func (x *KeyspaceIdType) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), KeyspaceIdType_value)
	if err != nil {
		return err
	}
	*x = KeyspaceIdType(i)
	return nil
}

// UnmarshalJSON unmarshals the KeyspaceIdType from JSON.
func (x *KeyspaceIdType) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the TabletType to JSON.
func (x TabletType) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), TabletType_name)
}

// MarshalText marshals the TabletType to text.
func (x TabletType) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), TabletType_name)), nil
}

// MarshalJSON marshals the TabletType to JSON.
func (x TabletType) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the TabletType from JSON.
func (x *TabletType) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(TabletType_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read TabletType enum: %v", err)
		return
	}
	*x = TabletType(v)
}

// UnmarshalText unmarshals the TabletType from text.
func (x *TabletType) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), TabletType_value)
	if err != nil {
		return err
	}
	*x = TabletType(i)
	return nil
}

// UnmarshalJSON unmarshals the TabletType from JSON.
func (x *TabletType) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the KeyRange message to JSON.
func (x *KeyRange) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Start) > 0 || s.HasField("start") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("start")
		s.WriteBytes(x.Start)
	}
	if len(x.End) > 0 || s.HasField("end") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("end")
		s.WriteBytes(x.End)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the KeyRange to JSON.
func (x *KeyRange) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the KeyRange message from JSON.
func (x *KeyRange) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "start":
			s.AddField("start")
			x.Start = s.ReadBytes()
		case "end":
			s.AddField("end")
			x.End = s.ReadBytes()
		}
	})
}

// UnmarshalJSON unmarshals the KeyRange from JSON.
func (x *KeyRange) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the TabletAlias message to JSON.
func (x *TabletAlias) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Cell != "" || s.HasField("cell") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("cell")
		s.WriteString(x.Cell)
	}
	if x.Uid != 0 || s.HasField("uid") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("uid")
		s.WriteUint32(x.Uid)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the TabletAlias to JSON.
func (x *TabletAlias) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the TabletAlias message from JSON.
func (x *TabletAlias) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "cell":
			s.AddField("cell")
			x.Cell = s.ReadString()
		case "uid":
			s.AddField("uid")
			x.Uid = s.ReadUint32()
		}
	})
}

// UnmarshalJSON unmarshals the TabletAlias from JSON.
func (x *TabletAlias) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Tablet_PortMapEntry message to JSON.
func (x *Tablet_PortMapEntry) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Key != "" || s.HasField("key") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("key")
		s.WriteString(x.Key)
	}
	if x.Value != 0 || s.HasField("value") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("value")
		s.WriteInt32(x.Value)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Tablet_PortMapEntry to JSON.
func (x *Tablet_PortMapEntry) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Tablet_PortMapEntry message from JSON.
func (x *Tablet_PortMapEntry) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "key":
			s.AddField("key")
			x.Key = s.ReadString()
		case "value":
			s.AddField("value")
			x.Value = s.ReadInt32()
		}
	})
}

// UnmarshalJSON unmarshals the Tablet_PortMapEntry from JSON.
func (x *Tablet_PortMapEntry) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Tablet_TagsEntry message to JSON.
func (x *Tablet_TagsEntry) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Key != "" || s.HasField("key") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("key")
		s.WriteString(x.Key)
	}
	if x.Value != "" || s.HasField("value") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("value")
		s.WriteString(x.Value)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Tablet_TagsEntry to JSON.
func (x *Tablet_TagsEntry) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Tablet_TagsEntry message from JSON.
func (x *Tablet_TagsEntry) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "key":
			s.AddField("key")
			x.Key = s.ReadString()
		case "value":
			s.AddField("value")
			x.Value = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the Tablet_TagsEntry from JSON.
func (x *Tablet_TagsEntry) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Tablet message to JSON.
func (x *Tablet) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Alias != nil || s.HasField("alias") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("alias")
		x.Alias.MarshalProtoJSON(s.WithField("alias"))
	}
	if x.Hostname != "" || s.HasField("hostname") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("hostname")
		s.WriteString(x.Hostname)
	}
	if x.PortMap != nil || s.HasField("portMap") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("portMap")
		s.WriteObjectStart()
		var wroteElement bool
		for k, v := range x.PortMap {
			s.WriteMoreIf(&wroteElement)
			s.WriteObjectStringField(k)
			s.WriteInt32(v)
		}
		s.WriteObjectEnd()
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.Shard != "" || s.HasField("shard") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shard")
		s.WriteString(x.Shard)
	}
	if x.KeyRange != nil || s.HasField("keyRange") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRange")
		x.KeyRange.MarshalProtoJSON(s.WithField("keyRange"))
	}
	if x.Type != 0 || s.HasField("type") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("type")
		x.Type.MarshalProtoJSON(s)
	}
	if x.DbNameOverride != "" || s.HasField("dbNameOverride") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("dbNameOverride")
		s.WriteString(x.DbNameOverride)
	}
	if x.Tags != nil || s.HasField("tags") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tags")
		s.WriteObjectStart()
		var wroteElement bool
		for k, v := range x.Tags {
			s.WriteMoreIf(&wroteElement)
			s.WriteObjectStringField(k)
			s.WriteString(v)
		}
		s.WriteObjectEnd()
	}
	if x.MysqlHostname != "" || s.HasField("mysqlHostname") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("mysqlHostname")
		s.WriteString(x.MysqlHostname)
	}
	if x.MysqlPort != 0 || s.HasField("mysqlPort") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("mysqlPort")
		s.WriteInt32(x.MysqlPort)
	}
	if x.MasterTermStartTime != nil || s.HasField("masterTermStartTime") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("masterTermStartTime")
		x.MasterTermStartTime.MarshalProtoJSON(s.WithField("masterTermStartTime"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Tablet to JSON.
func (x *Tablet) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Tablet message from JSON.
func (x *Tablet) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "alias":
			if s.ReadNil() {
				x.Alias = nil
				return
			}
			x.Alias = &TabletAlias{}
			x.Alias.UnmarshalProtoJSON(s.WithField("alias", true))
		case "hostname":
			s.AddField("hostname")
			x.Hostname = s.ReadString()
		case "port_map", "portMap":
			s.AddField("port_map")
			if s.ReadNil() {
				x.PortMap = nil
				return
			}
			x.PortMap = make(map[string]int32)
			s.ReadStringMap(func(key string) {
				x.PortMap[key] = s.ReadInt32()
			})
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shard":
			s.AddField("shard")
			x.Shard = s.ReadString()
		case "key_range", "keyRange":
			if s.ReadNil() {
				x.KeyRange = nil
				return
			}
			x.KeyRange = &KeyRange{}
			x.KeyRange.UnmarshalProtoJSON(s.WithField("key_range", true))
		case "type":
			s.AddField("type")
			x.Type.UnmarshalProtoJSON(s)
		case "db_name_override", "dbNameOverride":
			s.AddField("db_name_override")
			x.DbNameOverride = s.ReadString()
		case "tags":
			s.AddField("tags")
			if s.ReadNil() {
				x.Tags = nil
				return
			}
			x.Tags = make(map[string]string)
			s.ReadStringMap(func(key string) {
				x.Tags[key] = s.ReadString()
			})
		case "mysql_hostname", "mysqlHostname":
			s.AddField("mysql_hostname")
			x.MysqlHostname = s.ReadString()
		case "mysql_port", "mysqlPort":
			s.AddField("mysql_port")
			x.MysqlPort = s.ReadInt32()
		case "master_term_start_time", "masterTermStartTime":
			if s.ReadNil() {
				x.MasterTermStartTime = nil
				return
			}
			x.MasterTermStartTime = &vttime.Time{}
			x.MasterTermStartTime.UnmarshalProtoJSON(s.WithField("master_term_start_time", true))
		}
	})
}

// UnmarshalJSON unmarshals the Tablet from JSON.
func (x *Tablet) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Shard_ServedType message to JSON.
func (x *Shard_ServedType) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if len(x.Cells) > 0 || s.HasField("cells") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("cells")
		s.WriteStringArray(x.Cells)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Shard_ServedType to JSON.
func (x *Shard_ServedType) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Shard_ServedType message from JSON.
func (x *Shard_ServedType) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "cells":
			s.AddField("cells")
			if s.ReadNil() {
				x.Cells = nil
				return
			}
			x.Cells = s.ReadStringArray()
		}
	})
}

// UnmarshalJSON unmarshals the Shard_ServedType from JSON.
func (x *Shard_ServedType) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Shard_SourceShard message to JSON.
func (x *Shard_SourceShard) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Uid != 0 || s.HasField("uid") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("uid")
		s.WriteUint32(x.Uid)
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	if x.Shard != "" || s.HasField("shard") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shard")
		s.WriteString(x.Shard)
	}
	if x.KeyRange != nil || s.HasField("keyRange") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRange")
		x.KeyRange.MarshalProtoJSON(s.WithField("keyRange"))
	}
	if len(x.Tables) > 0 || s.HasField("tables") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tables")
		s.WriteStringArray(x.Tables)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Shard_SourceShard to JSON.
func (x *Shard_SourceShard) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Shard_SourceShard message from JSON.
func (x *Shard_SourceShard) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "uid":
			s.AddField("uid")
			x.Uid = s.ReadUint32()
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		case "shard":
			s.AddField("shard")
			x.Shard = s.ReadString()
		case "key_range", "keyRange":
			if s.ReadNil() {
				x.KeyRange = nil
				return
			}
			x.KeyRange = &KeyRange{}
			x.KeyRange.UnmarshalProtoJSON(s.WithField("key_range", true))
		case "tables":
			s.AddField("tables")
			if s.ReadNil() {
				x.Tables = nil
				return
			}
			x.Tables = s.ReadStringArray()
		}
	})
}

// UnmarshalJSON unmarshals the Shard_SourceShard from JSON.
func (x *Shard_SourceShard) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Shard_TabletControl message to JSON.
func (x *Shard_TabletControl) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if len(x.Cells) > 0 || s.HasField("cells") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("cells")
		s.WriteStringArray(x.Cells)
	}
	if len(x.BlacklistedTables) > 0 || s.HasField("blacklistedTables") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("blacklistedTables")
		s.WriteStringArray(x.BlacklistedTables)
	}
	if x.Frozen || s.HasField("frozen") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("frozen")
		s.WriteBool(x.Frozen)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Shard_TabletControl to JSON.
func (x *Shard_TabletControl) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Shard_TabletControl message from JSON.
func (x *Shard_TabletControl) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "cells":
			s.AddField("cells")
			if s.ReadNil() {
				x.Cells = nil
				return
			}
			x.Cells = s.ReadStringArray()
		case "blacklisted_tables", "blacklistedTables":
			s.AddField("blacklisted_tables")
			if s.ReadNil() {
				x.BlacklistedTables = nil
				return
			}
			x.BlacklistedTables = s.ReadStringArray()
		case "frozen":
			s.AddField("frozen")
			x.Frozen = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the Shard_TabletControl from JSON.
func (x *Shard_TabletControl) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Shard message to JSON.
func (x *Shard) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.MasterAlias != nil || s.HasField("masterAlias") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("masterAlias")
		x.MasterAlias.MarshalProtoJSON(s.WithField("masterAlias"))
	}
	if x.KeyRange != nil || s.HasField("keyRange") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRange")
		x.KeyRange.MarshalProtoJSON(s.WithField("keyRange"))
	}
	if len(x.ServedTypes) > 0 || s.HasField("servedTypes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("servedTypes")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.ServedTypes {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("servedTypes"))
		}
		s.WriteArrayEnd()
	}
	if len(x.SourceShards) > 0 || s.HasField("sourceShards") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("sourceShards")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.SourceShards {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("sourceShards"))
		}
		s.WriteArrayEnd()
	}
	if len(x.TabletControls) > 0 || s.HasField("tabletControls") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletControls")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.TabletControls {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("tabletControls"))
		}
		s.WriteArrayEnd()
	}
	if x.IsMasterServing || s.HasField("isMasterServing") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("isMasterServing")
		s.WriteBool(x.IsMasterServing)
	}
	if x.MasterTermStartTime != nil || s.HasField("masterTermStartTime") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("masterTermStartTime")
		x.MasterTermStartTime.MarshalProtoJSON(s.WithField("masterTermStartTime"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Shard to JSON.
func (x *Shard) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Shard message from JSON.
func (x *Shard) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "master_alias", "masterAlias":
			if s.ReadNil() {
				x.MasterAlias = nil
				return
			}
			x.MasterAlias = &TabletAlias{}
			x.MasterAlias.UnmarshalProtoJSON(s.WithField("master_alias", true))
		case "key_range", "keyRange":
			if s.ReadNil() {
				x.KeyRange = nil
				return
			}
			x.KeyRange = &KeyRange{}
			x.KeyRange.UnmarshalProtoJSON(s.WithField("key_range", true))
		case "served_types", "servedTypes":
			s.AddField("served_types")
			if s.ReadNil() {
				x.ServedTypes = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.ServedTypes = append(x.ServedTypes, nil)
					return
				}
				v := &Shard_ServedType{}
				v.UnmarshalProtoJSON(s.WithField("served_types", false))
				if s.Err() != nil {
					return
				}
				x.ServedTypes = append(x.ServedTypes, v)
			})
		case "source_shards", "sourceShards":
			s.AddField("source_shards")
			if s.ReadNil() {
				x.SourceShards = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.SourceShards = append(x.SourceShards, nil)
					return
				}
				v := &Shard_SourceShard{}
				v.UnmarshalProtoJSON(s.WithField("source_shards", false))
				if s.Err() != nil {
					return
				}
				x.SourceShards = append(x.SourceShards, v)
			})
		case "tablet_controls", "tabletControls":
			s.AddField("tablet_controls")
			if s.ReadNil() {
				x.TabletControls = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.TabletControls = append(x.TabletControls, nil)
					return
				}
				v := &Shard_TabletControl{}
				v.UnmarshalProtoJSON(s.WithField("tablet_controls", false))
				if s.Err() != nil {
					return
				}
				x.TabletControls = append(x.TabletControls, v)
			})
		case "is_master_serving", "isMasterServing":
			s.AddField("is_master_serving")
			x.IsMasterServing = s.ReadBool()
		case "master_term_start_time", "masterTermStartTime":
			if s.ReadNil() {
				x.MasterTermStartTime = nil
				return
			}
			x.MasterTermStartTime = &vttime.Time{}
			x.MasterTermStartTime.UnmarshalProtoJSON(s.WithField("master_term_start_time", true))
		}
	})
}

// UnmarshalJSON unmarshals the Shard from JSON.
func (x *Shard) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Keyspace_ServedFrom message to JSON.
func (x *Keyspace_ServedFrom) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if len(x.Cells) > 0 || s.HasField("cells") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("cells")
		s.WriteStringArray(x.Cells)
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Keyspace_ServedFrom to JSON.
func (x *Keyspace_ServedFrom) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Keyspace_ServedFrom message from JSON.
func (x *Keyspace_ServedFrom) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "cells":
			s.AddField("cells")
			if s.ReadNil() {
				x.Cells = nil
				return
			}
			x.Cells = s.ReadStringArray()
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the Keyspace_ServedFrom from JSON.
func (x *Keyspace_ServedFrom) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Keyspace message to JSON.
func (x *Keyspace) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.ShardingColumnName != "" || s.HasField("shardingColumnName") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardingColumnName")
		s.WriteString(x.ShardingColumnName)
	}
	if x.ShardingColumnType != 0 || s.HasField("shardingColumnType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardingColumnType")
		x.ShardingColumnType.MarshalProtoJSON(s)
	}
	if len(x.ServedFroms) > 0 || s.HasField("servedFroms") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("servedFroms")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.ServedFroms {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("servedFroms"))
		}
		s.WriteArrayEnd()
	}
	if x.KeyspaceType != 0 || s.HasField("keyspaceType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspaceType")
		x.KeyspaceType.MarshalProtoJSON(s)
	}
	if x.BaseKeyspace != "" || s.HasField("baseKeyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("baseKeyspace")
		s.WriteString(x.BaseKeyspace)
	}
	if x.SnapshotTime != nil || s.HasField("snapshotTime") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("snapshotTime")
		x.SnapshotTime.MarshalProtoJSON(s.WithField("snapshotTime"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Keyspace to JSON.
func (x *Keyspace) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Keyspace message from JSON.
func (x *Keyspace) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "sharding_column_name", "shardingColumnName":
			s.AddField("sharding_column_name")
			x.ShardingColumnName = s.ReadString()
		case "sharding_column_type", "shardingColumnType":
			s.AddField("sharding_column_type")
			x.ShardingColumnType.UnmarshalProtoJSON(s)
		case "served_froms", "servedFroms":
			s.AddField("served_froms")
			if s.ReadNil() {
				x.ServedFroms = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.ServedFroms = append(x.ServedFroms, nil)
					return
				}
				v := &Keyspace_ServedFrom{}
				v.UnmarshalProtoJSON(s.WithField("served_froms", false))
				if s.Err() != nil {
					return
				}
				x.ServedFroms = append(x.ServedFroms, v)
			})
		case "keyspace_type", "keyspaceType":
			s.AddField("keyspace_type")
			x.KeyspaceType.UnmarshalProtoJSON(s)
		case "base_keyspace", "baseKeyspace":
			s.AddField("base_keyspace")
			x.BaseKeyspace = s.ReadString()
		case "snapshot_time", "snapshotTime":
			if s.ReadNil() {
				x.SnapshotTime = nil
				return
			}
			x.SnapshotTime = &vttime.Time{}
			x.SnapshotTime.UnmarshalProtoJSON(s.WithField("snapshot_time", true))
		}
	})
}

// UnmarshalJSON unmarshals the Keyspace from JSON.
func (x *Keyspace) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ShardReplication_Node message to JSON.
func (x *ShardReplication_Node) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.TabletAlias != nil || s.HasField("tabletAlias") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletAlias")
		x.TabletAlias.MarshalProtoJSON(s.WithField("tabletAlias"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ShardReplication_Node to JSON.
func (x *ShardReplication_Node) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ShardReplication_Node message from JSON.
func (x *ShardReplication_Node) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "tablet_alias", "tabletAlias":
			if s.ReadNil() {
				x.TabletAlias = nil
				return
			}
			x.TabletAlias = &TabletAlias{}
			x.TabletAlias.UnmarshalProtoJSON(s.WithField("tablet_alias", true))
		}
	})
}

// UnmarshalJSON unmarshals the ShardReplication_Node from JSON.
func (x *ShardReplication_Node) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ShardReplication message to JSON.
func (x *ShardReplication) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Nodes) > 0 || s.HasField("nodes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("nodes")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Nodes {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("nodes"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ShardReplication to JSON.
func (x *ShardReplication) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ShardReplication message from JSON.
func (x *ShardReplication) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "nodes":
			s.AddField("nodes")
			if s.ReadNil() {
				x.Nodes = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Nodes = append(x.Nodes, nil)
					return
				}
				v := &ShardReplication_Node{}
				v.UnmarshalProtoJSON(s.WithField("nodes", false))
				if s.Err() != nil {
					return
				}
				x.Nodes = append(x.Nodes, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the ShardReplication from JSON.
func (x *ShardReplication) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ShardReference message to JSON.
func (x *ShardReference) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Name != "" || s.HasField("name") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("name")
		s.WriteString(x.Name)
	}
	if x.KeyRange != nil || s.HasField("keyRange") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRange")
		x.KeyRange.MarshalProtoJSON(s.WithField("keyRange"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ShardReference to JSON.
func (x *ShardReference) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ShardReference message from JSON.
func (x *ShardReference) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "name":
			s.AddField("name")
			x.Name = s.ReadString()
		case "key_range", "keyRange":
			if s.ReadNil() {
				x.KeyRange = nil
				return
			}
			x.KeyRange = &KeyRange{}
			x.KeyRange.UnmarshalProtoJSON(s.WithField("key_range", true))
		}
	})
}

// UnmarshalJSON unmarshals the ShardReference from JSON.
func (x *ShardReference) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ShardTabletControl message to JSON.
func (x *ShardTabletControl) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Name != "" || s.HasField("name") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("name")
		s.WriteString(x.Name)
	}
	if x.KeyRange != nil || s.HasField("keyRange") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyRange")
		x.KeyRange.MarshalProtoJSON(s.WithField("keyRange"))
	}
	if x.QueryServiceDisabled || s.HasField("queryServiceDisabled") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("queryServiceDisabled")
		s.WriteBool(x.QueryServiceDisabled)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ShardTabletControl to JSON.
func (x *ShardTabletControl) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ShardTabletControl message from JSON.
func (x *ShardTabletControl) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "name":
			s.AddField("name")
			x.Name = s.ReadString()
		case "key_range", "keyRange":
			if s.ReadNil() {
				x.KeyRange = nil
				return
			}
			x.KeyRange = &KeyRange{}
			x.KeyRange.UnmarshalProtoJSON(s.WithField("key_range", true))
		case "query_service_disabled", "queryServiceDisabled":
			s.AddField("query_service_disabled")
			x.QueryServiceDisabled = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the ShardTabletControl from JSON.
func (x *ShardTabletControl) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SrvKeyspace_KeyspacePartition message to JSON.
func (x *SrvKeyspace_KeyspacePartition) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.ServedType != 0 || s.HasField("servedType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("servedType")
		x.ServedType.MarshalProtoJSON(s)
	}
	if len(x.ShardReferences) > 0 || s.HasField("shardReferences") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardReferences")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.ShardReferences {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("shardReferences"))
		}
		s.WriteArrayEnd()
	}
	if len(x.ShardTabletControls) > 0 || s.HasField("shardTabletControls") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardTabletControls")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.ShardTabletControls {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("shardTabletControls"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SrvKeyspace_KeyspacePartition to JSON.
func (x *SrvKeyspace_KeyspacePartition) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SrvKeyspace_KeyspacePartition message from JSON.
func (x *SrvKeyspace_KeyspacePartition) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "served_type", "servedType":
			s.AddField("served_type")
			x.ServedType.UnmarshalProtoJSON(s)
		case "shard_references", "shardReferences":
			s.AddField("shard_references")
			if s.ReadNil() {
				x.ShardReferences = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.ShardReferences = append(x.ShardReferences, nil)
					return
				}
				v := &ShardReference{}
				v.UnmarshalProtoJSON(s.WithField("shard_references", false))
				if s.Err() != nil {
					return
				}
				x.ShardReferences = append(x.ShardReferences, v)
			})
		case "shard_tablet_controls", "shardTabletControls":
			s.AddField("shard_tablet_controls")
			if s.ReadNil() {
				x.ShardTabletControls = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.ShardTabletControls = append(x.ShardTabletControls, nil)
					return
				}
				v := &ShardTabletControl{}
				v.UnmarshalProtoJSON(s.WithField("shard_tablet_controls", false))
				if s.Err() != nil {
					return
				}
				x.ShardTabletControls = append(x.ShardTabletControls, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the SrvKeyspace_KeyspacePartition from JSON.
func (x *SrvKeyspace_KeyspacePartition) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SrvKeyspace_ServedFrom message to JSON.
func (x *SrvKeyspace_ServedFrom) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.TabletType != 0 || s.HasField("tabletType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("tabletType")
		x.TabletType.MarshalProtoJSON(s)
	}
	if x.Keyspace != "" || s.HasField("keyspace") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyspace")
		s.WriteString(x.Keyspace)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SrvKeyspace_ServedFrom to JSON.
func (x *SrvKeyspace_ServedFrom) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SrvKeyspace_ServedFrom message from JSON.
func (x *SrvKeyspace_ServedFrom) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "tablet_type", "tabletType":
			s.AddField("tablet_type")
			x.TabletType.UnmarshalProtoJSON(s)
		case "keyspace":
			s.AddField("keyspace")
			x.Keyspace = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the SrvKeyspace_ServedFrom from JSON.
func (x *SrvKeyspace_ServedFrom) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SrvKeyspace message to JSON.
func (x *SrvKeyspace) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Partitions) > 0 || s.HasField("partitions") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("partitions")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Partitions {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("partitions"))
		}
		s.WriteArrayEnd()
	}
	if x.ShardingColumnName != "" || s.HasField("shardingColumnName") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardingColumnName")
		s.WriteString(x.ShardingColumnName)
	}
	if x.ShardingColumnType != 0 || s.HasField("shardingColumnType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shardingColumnType")
		x.ShardingColumnType.MarshalProtoJSON(s)
	}
	if len(x.ServedFrom) > 0 || s.HasField("servedFrom") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("servedFrom")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.ServedFrom {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("servedFrom"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SrvKeyspace to JSON.
func (x *SrvKeyspace) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SrvKeyspace message from JSON.
func (x *SrvKeyspace) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "partitions":
			s.AddField("partitions")
			if s.ReadNil() {
				x.Partitions = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Partitions = append(x.Partitions, nil)
					return
				}
				v := &SrvKeyspace_KeyspacePartition{}
				v.UnmarshalProtoJSON(s.WithField("partitions", false))
				if s.Err() != nil {
					return
				}
				x.Partitions = append(x.Partitions, v)
			})
		case "sharding_column_name", "shardingColumnName":
			s.AddField("sharding_column_name")
			x.ShardingColumnName = s.ReadString()
		case "sharding_column_type", "shardingColumnType":
			s.AddField("sharding_column_type")
			x.ShardingColumnType.UnmarshalProtoJSON(s)
		case "served_from", "servedFrom":
			s.AddField("served_from")
			if s.ReadNil() {
				x.ServedFrom = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.ServedFrom = append(x.ServedFrom, nil)
					return
				}
				v := &SrvKeyspace_ServedFrom{}
				v.UnmarshalProtoJSON(s.WithField("served_from", false))
				if s.Err() != nil {
					return
				}
				x.ServedFrom = append(x.ServedFrom, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the SrvKeyspace from JSON.
func (x *SrvKeyspace) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the CellInfo message to JSON.
func (x *CellInfo) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.ServerAddress != "" || s.HasField("serverAddress") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("serverAddress")
		s.WriteString(x.ServerAddress)
	}
	if x.Root != "" || s.HasField("root") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("root")
		s.WriteString(x.Root)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the CellInfo to JSON.
func (x *CellInfo) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the CellInfo message from JSON.
func (x *CellInfo) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "server_address", "serverAddress":
			s.AddField("server_address")
			x.ServerAddress = s.ReadString()
		case "root":
			s.AddField("root")
			x.Root = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the CellInfo from JSON.
func (x *CellInfo) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the CellsAlias message to JSON.
func (x *CellsAlias) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Cells) > 0 || s.HasField("cells") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("cells")
		s.WriteStringArray(x.Cells)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the CellsAlias to JSON.
func (x *CellsAlias) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the CellsAlias message from JSON.
func (x *CellsAlias) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "cells":
			s.AddField("cells")
			if s.ReadNil() {
				x.Cells = nil
				return
			}
			x.Cells = s.ReadStringArray()
		}
	})
}

// UnmarshalJSON unmarshals the CellsAlias from JSON.
func (x *CellsAlias) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

func (m *KeyRange) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *KeyRange) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.End) > 0 {
		i -= len(m.End)
		copy(dAtA[i:], m.End)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.End)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Start) > 0 {
		i -= len(m.Start)
		copy(dAtA[i:], m.Start)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Start)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TabletAlias) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TabletAlias) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TabletAlias) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Uid != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cell) > 0 {
		i -= len(m.Cell)
		copy(dAtA[i:], m.Cell)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Cell)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tablet) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tablet) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Tablet) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.MasterTermStartTime != nil {
		size, err := m.MasterTermStartTime.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x72
	}
	if m.MysqlPort != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.MysqlPort))
		i--
		dAtA[i] = 0x68
	}
	if len(m.MysqlHostname) > 0 {
		i -= len(m.MysqlHostname)
		copy(dAtA[i:], m.MysqlHostname)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.MysqlHostname)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.DbNameOverride) > 0 {
		i -= len(m.DbNameOverride)
		copy(dAtA[i:], m.DbNameOverride)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.DbNameOverride)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Type != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x40
	}
	if m.KeyRange != nil {
		size, err := m.KeyRange.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PortMap) > 0 {
		for k := range m.PortMap {
			v := m.PortMap[k]
			baseI := i
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Alias != nil {
		size, err := m.Alias.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Shard_ServedType) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard_ServedType) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Shard_ServedType) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cells[iNdEx])
			copy(dAtA[i:], m.Cells[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Cells[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shard_SourceShard) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard_SourceShard) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Shard_SourceShard) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tables[iNdEx])
			copy(dAtA[i:], m.Tables[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Tables[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.KeyRange != nil {
		size, err := m.KeyRange.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shard_TabletControl) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard_TabletControl) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Shard_TabletControl) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Frozen {
		i--
		if m.Frozen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.BlacklistedTables) > 0 {
		for iNdEx := len(m.BlacklistedTables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BlacklistedTables[iNdEx])
			copy(dAtA[i:], m.BlacklistedTables[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.BlacklistedTables[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cells[iNdEx])
			copy(dAtA[i:], m.Cells[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Cells[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shard) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Shard) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.MasterTermStartTime != nil {
		size, err := m.MasterTermStartTime.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.IsMasterServing {
		i--
		if m.IsMasterServing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.TabletControls) > 0 {
		for iNdEx := len(m.TabletControls) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.TabletControls[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SourceShards) > 0 {
		for iNdEx := len(m.SourceShards) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.SourceShards[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ServedTypes) > 0 {
		for iNdEx := len(m.ServedTypes) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ServedTypes[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.KeyRange != nil {
		size, err := m.KeyRange.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.MasterAlias != nil {
		size, err := m.MasterAlias.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Keyspace_ServedFrom) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyspace_ServedFrom) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Keyspace_ServedFrom) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cells[iNdEx])
			copy(dAtA[i:], m.Cells[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Cells[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Keyspace) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyspace) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Keyspace) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.SnapshotTime != nil {
		size, err := m.SnapshotTime.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BaseKeyspace) > 0 {
		i -= len(m.BaseKeyspace)
		copy(dAtA[i:], m.BaseKeyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.BaseKeyspace)))
		i--
		dAtA[i] = 0x32
	}
	if m.KeyspaceType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.KeyspaceType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ServedFroms) > 0 {
		for iNdEx := len(m.ServedFroms) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ServedFroms[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ShardingColumnType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.ShardingColumnType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ShardingColumnName) > 0 {
		i -= len(m.ShardingColumnName)
		copy(dAtA[i:], m.ShardingColumnName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ShardingColumnName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardReplication_Node) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardReplication_Node) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ShardReplication_Node) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.TabletAlias != nil {
		size, err := m.TabletAlias.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardReplication) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardReplication) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ShardReplication) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Nodes[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShardReference) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardReference) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ShardReference) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.KeyRange != nil {
		size, err := m.KeyRange.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardTabletControl) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardTabletControl) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ShardTabletControl) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.QueryServiceDisabled {
		i--
		if m.QueryServiceDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.KeyRange != nil {
		size, err := m.KeyRange.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SrvKeyspace_KeyspacePartition) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SrvKeyspace_KeyspacePartition) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SrvKeyspace_KeyspacePartition) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ShardTabletControls) > 0 {
		for iNdEx := len(m.ShardTabletControls) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ShardTabletControls[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ShardReferences) > 0 {
		for iNdEx := len(m.ShardReferences) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ShardReferences[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ServedType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.ServedType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SrvKeyspace_ServedFrom) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SrvKeyspace_ServedFrom) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SrvKeyspace_ServedFrom) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if m.TabletType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SrvKeyspace) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SrvKeyspace) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SrvKeyspace) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ServedFrom) > 0 {
		for iNdEx := len(m.ServedFrom) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ServedFrom[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ShardingColumnType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.ShardingColumnType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ShardingColumnName) > 0 {
		i -= len(m.ShardingColumnName)
		copy(dAtA[i:], m.ShardingColumnName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ShardingColumnName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Partitions[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CellInfo) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellInfo) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CellInfo) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerAddress) > 0 {
		i -= len(m.ServerAddress)
		copy(dAtA[i:], m.ServerAddress)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ServerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CellsAlias) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellsAlias) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CellsAlias) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cells[iNdEx])
			copy(dAtA[i:], m.Cells[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Cells[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyRange) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TabletAlias) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cell)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Uid))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Tablet) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Alias != nil {
		l = m.Alias.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.PortMap) > 0 {
		for k, v := range m.PortMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + protobuf_go_lite.SizeOfVarint(uint64(len(k))) + 1 + protobuf_go_lite.SizeOfVarint(uint64(v))
			n += mapEntrySize + 1 + protobuf_go_lite.SizeOfVarint(uint64(mapEntrySize))
		}
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Type))
	}
	l = len(m.DbNameOverride)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + protobuf_go_lite.SizeOfVarint(uint64(len(k))) + 1 + len(v) + protobuf_go_lite.SizeOfVarint(uint64(len(v)))
			n += mapEntrySize + 1 + protobuf_go_lite.SizeOfVarint(uint64(mapEntrySize))
		}
	}
	l = len(m.MysqlHostname)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.MysqlPort != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.MysqlPort))
	}
	if m.MasterTermStartTime != nil {
		l = m.MasterTermStartTime.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Shard_ServedType) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if len(m.Cells) > 0 {
		for _, s := range m.Cells {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *Shard_SourceShard) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Uid))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *Shard_TabletControl) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if len(m.Cells) > 0 {
		for _, s := range m.Cells {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.BlacklistedTables) > 0 {
		for _, s := range m.BlacklistedTables {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Frozen {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Shard) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MasterAlias != nil {
		l = m.MasterAlias.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.ServedTypes) > 0 {
		for _, e := range m.ServedTypes {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.SourceShards) > 0 {
		for _, e := range m.SourceShards {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.TabletControls) > 0 {
		for _, e := range m.TabletControls {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.IsMasterServing {
		n += 2
	}
	if m.MasterTermStartTime != nil {
		l = m.MasterTermStartTime.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Keyspace_ServedFrom) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	if len(m.Cells) > 0 {
		for _, s := range m.Cells {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Keyspace) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShardingColumnName)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.ShardingColumnType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.ShardingColumnType))
	}
	if len(m.ServedFroms) > 0 {
		for _, e := range m.ServedFroms {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.KeyspaceType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.KeyspaceType))
	}
	l = len(m.BaseKeyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.SnapshotTime != nil {
		l = m.SnapshotTime.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ShardReplication_Node) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabletAlias != nil {
		l = m.TabletAlias.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ShardReplication) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ShardReference) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ShardTabletControl) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.QueryServiceDisabled {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *SrvKeyspace_KeyspacePartition) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServedType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.ServedType))
	}
	if len(m.ShardReferences) > 0 {
		for _, e := range m.ShardReferences {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.ShardTabletControls) > 0 {
		for _, e := range m.ShardTabletControls {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *SrvKeyspace_ServedFrom) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabletType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TabletType))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *SrvKeyspace) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	l = len(m.ShardingColumnName)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.ShardingColumnType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.ShardingColumnType))
	}
	if len(m.ServedFrom) > 0 {
		for _, e := range m.ServedFrom {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *CellInfo) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerAddress)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *CellsAlias) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for _, s := range m.Cells {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (x KeyspaceType) MarshalProtoText() string {
	return x.String()
}
func (x KeyspaceIdType) MarshalProtoText() string {
	return x.String()
}
func (x TabletType) MarshalProtoText() string {
	return x.String()
}
func (x *KeyRange) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("KeyRange { ")
	if len(x.Start) > 0 {
		sb.WriteString(" start: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Start))
		sb.WriteString("\"")
	}
	if len(x.End) > 0 {
		sb.WriteString(" end: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.End))
		sb.WriteString("\"")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *KeyRange) String() string {
	return x.MarshalProtoText()
}
func (x *TabletAlias) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("TabletAlias { ")
	if x.Cell != "" {
		sb.WriteString(" cell: ")
		sb.WriteString(strconv.Quote(x.Cell))
	}
	if x.Uid != 0 {
		sb.WriteString(" uid: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Uid), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *TabletAlias) String() string {
	return x.MarshalProtoText()
}
func (x *Tablet_PortMapEntry) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("PortMapEntry { ")
	if x.Key != "" {
		sb.WriteString(" key: ")
		sb.WriteString(strconv.Quote(x.Key))
	}
	if x.Value != 0 {
		sb.WriteString(" value: ")
		sb.WriteString(strconv.FormatInt(int64(x.Value), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Tablet_PortMapEntry) String() string {
	return x.MarshalProtoText()
}
func (x *Tablet_TagsEntry) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("TagsEntry { ")
	if x.Key != "" {
		sb.WriteString(" key: ")
		sb.WriteString(strconv.Quote(x.Key))
	}
	if x.Value != "" {
		sb.WriteString(" value: ")
		sb.WriteString(strconv.Quote(x.Value))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Tablet_TagsEntry) String() string {
	return x.MarshalProtoText()
}
func (x *Tablet) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Tablet { ")
	if x.Alias != nil {
		sb.WriteString(" alias: ")
		sb.WriteString(x.Alias.MarshalProtoText())
	}
	if x.Hostname != "" {
		sb.WriteString(" hostname: ")
		sb.WriteString(strconv.Quote(x.Hostname))
	}
	if len(x.PortMap) > 0 {
		sb.WriteString(" port_map: {")
		for k, v := range x.PortMap {
			sb.WriteString(" ")
			sb.WriteString(strconv.Quote(k))
			sb.WriteString(": ")
			sb.WriteString(strconv.FormatInt(int64(v), 10))
		}
		sb.WriteString(" }")
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.Shard != "" {
		sb.WriteString(" shard: ")
		sb.WriteString(strconv.Quote(x.Shard))
	}
	if x.KeyRange != nil {
		sb.WriteString(" key_range: ")
		sb.WriteString(x.KeyRange.MarshalProtoText())
	}
	if x.Type != 0 {
		sb.WriteString(" type: ")
		sb.WriteString(TabletType(x.Type).String())
	}
	if x.DbNameOverride != "" {
		sb.WriteString(" db_name_override: ")
		sb.WriteString(strconv.Quote(x.DbNameOverride))
	}
	if len(x.Tags) > 0 {
		sb.WriteString(" tags: {")
		for k, v := range x.Tags {
			sb.WriteString(" ")
			sb.WriteString(strconv.Quote(k))
			sb.WriteString(": ")
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString(" }")
	}
	if x.MysqlHostname != "" {
		sb.WriteString(" mysql_hostname: ")
		sb.WriteString(strconv.Quote(x.MysqlHostname))
	}
	if x.MysqlPort != 0 {
		sb.WriteString(" mysql_port: ")
		sb.WriteString(strconv.FormatInt(int64(x.MysqlPort), 10))
	}
	if x.MasterTermStartTime != nil {
		sb.WriteString(" master_term_start_time: ")
		sb.WriteString(x.MasterTermStartTime.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Tablet) String() string {
	return x.MarshalProtoText()
}
func (x *Shard_ServedType) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ServedType { ")
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(TabletType(x.TabletType).String())
	}
	if len(x.Cells) > 0 {
		sb.WriteString(" cells: [")
		for i, v := range x.Cells {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Shard_ServedType) String() string {
	return x.MarshalProtoText()
}
func (x *Shard_SourceShard) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("SourceShard { ")
	if x.Uid != 0 {
		sb.WriteString(" uid: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Uid), 10))
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	if x.Shard != "" {
		sb.WriteString(" shard: ")
		sb.WriteString(strconv.Quote(x.Shard))
	}
	if x.KeyRange != nil {
		sb.WriteString(" key_range: ")
		sb.WriteString(x.KeyRange.MarshalProtoText())
	}
	if len(x.Tables) > 0 {
		sb.WriteString(" tables: [")
		for i, v := range x.Tables {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Shard_SourceShard) String() string {
	return x.MarshalProtoText()
}
func (x *Shard_TabletControl) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("TabletControl { ")
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(TabletType(x.TabletType).String())
	}
	if len(x.Cells) > 0 {
		sb.WriteString(" cells: [")
		for i, v := range x.Cells {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if len(x.BlacklistedTables) > 0 {
		sb.WriteString(" blacklisted_tables: [")
		for i, v := range x.BlacklistedTables {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if x.Frozen {
		sb.WriteString(" frozen: ")
		sb.WriteString(strconv.FormatBool(x.Frozen))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Shard_TabletControl) String() string {
	return x.MarshalProtoText()
}
func (x *Shard) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Shard { ")
	if x.MasterAlias != nil {
		sb.WriteString(" master_alias: ")
		sb.WriteString(x.MasterAlias.MarshalProtoText())
	}
	if x.KeyRange != nil {
		sb.WriteString(" key_range: ")
		sb.WriteString(x.KeyRange.MarshalProtoText())
	}
	if len(x.ServedTypes) > 0 {
		sb.WriteString(" served_types: [")
		for i, v := range x.ServedTypes {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.SourceShards) > 0 {
		sb.WriteString(" source_shards: [")
		for i, v := range x.SourceShards {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.TabletControls) > 0 {
		sb.WriteString(" tablet_controls: [")
		for i, v := range x.TabletControls {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.IsMasterServing {
		sb.WriteString(" is_master_serving: ")
		sb.WriteString(strconv.FormatBool(x.IsMasterServing))
	}
	if x.MasterTermStartTime != nil {
		sb.WriteString(" master_term_start_time: ")
		sb.WriteString(x.MasterTermStartTime.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Shard) String() string {
	return x.MarshalProtoText()
}
func (x *Keyspace_ServedFrom) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ServedFrom { ")
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(TabletType(x.TabletType).String())
	}
	if len(x.Cells) > 0 {
		sb.WriteString(" cells: [")
		for i, v := range x.Cells {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Keyspace_ServedFrom) String() string {
	return x.MarshalProtoText()
}
func (x *Keyspace) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Keyspace { ")
	if x.ShardingColumnName != "" {
		sb.WriteString(" sharding_column_name: ")
		sb.WriteString(strconv.Quote(x.ShardingColumnName))
	}
	if x.ShardingColumnType != 0 {
		sb.WriteString(" sharding_column_type: ")
		sb.WriteString(KeyspaceIdType(x.ShardingColumnType).String())
	}
	if len(x.ServedFroms) > 0 {
		sb.WriteString(" served_froms: [")
		for i, v := range x.ServedFroms {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.KeyspaceType != 0 {
		sb.WriteString(" keyspace_type: ")
		sb.WriteString(KeyspaceType(x.KeyspaceType).String())
	}
	if x.BaseKeyspace != "" {
		sb.WriteString(" base_keyspace: ")
		sb.WriteString(strconv.Quote(x.BaseKeyspace))
	}
	if x.SnapshotTime != nil {
		sb.WriteString(" snapshot_time: ")
		sb.WriteString(x.SnapshotTime.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Keyspace) String() string {
	return x.MarshalProtoText()
}
func (x *ShardReplication_Node) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Node { ")
	if x.TabletAlias != nil {
		sb.WriteString(" tablet_alias: ")
		sb.WriteString(x.TabletAlias.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ShardReplication_Node) String() string {
	return x.MarshalProtoText()
}
func (x *ShardReplication) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ShardReplication { ")
	if len(x.Nodes) > 0 {
		sb.WriteString(" nodes: [")
		for i, v := range x.Nodes {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ShardReplication) String() string {
	return x.MarshalProtoText()
}
func (x *ShardReference) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ShardReference { ")
	if x.Name != "" {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(x.Name))
	}
	if x.KeyRange != nil {
		sb.WriteString(" key_range: ")
		sb.WriteString(x.KeyRange.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ShardReference) String() string {
	return x.MarshalProtoText()
}
func (x *ShardTabletControl) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ShardTabletControl { ")
	if x.Name != "" {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(x.Name))
	}
	if x.KeyRange != nil {
		sb.WriteString(" key_range: ")
		sb.WriteString(x.KeyRange.MarshalProtoText())
	}
	if x.QueryServiceDisabled {
		sb.WriteString(" query_service_disabled: ")
		sb.WriteString(strconv.FormatBool(x.QueryServiceDisabled))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ShardTabletControl) String() string {
	return x.MarshalProtoText()
}
func (x *SrvKeyspace_KeyspacePartition) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("KeyspacePartition { ")
	if x.ServedType != 0 {
		sb.WriteString(" served_type: ")
		sb.WriteString(TabletType(x.ServedType).String())
	}
	if len(x.ShardReferences) > 0 {
		sb.WriteString(" shard_references: [")
		for i, v := range x.ShardReferences {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.ShardTabletControls) > 0 {
		sb.WriteString(" shard_tablet_controls: [")
		for i, v := range x.ShardTabletControls {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SrvKeyspace_KeyspacePartition) String() string {
	return x.MarshalProtoText()
}
func (x *SrvKeyspace_ServedFrom) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ServedFrom { ")
	if x.TabletType != 0 {
		sb.WriteString(" tablet_type: ")
		sb.WriteString(TabletType(x.TabletType).String())
	}
	if x.Keyspace != "" {
		sb.WriteString(" keyspace: ")
		sb.WriteString(strconv.Quote(x.Keyspace))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SrvKeyspace_ServedFrom) String() string {
	return x.MarshalProtoText()
}
func (x *SrvKeyspace) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("SrvKeyspace { ")
	if len(x.Partitions) > 0 {
		sb.WriteString(" partitions: [")
		for i, v := range x.Partitions {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.ShardingColumnName != "" {
		sb.WriteString(" sharding_column_name: ")
		sb.WriteString(strconv.Quote(x.ShardingColumnName))
	}
	if x.ShardingColumnType != 0 {
		sb.WriteString(" sharding_column_type: ")
		sb.WriteString(KeyspaceIdType(x.ShardingColumnType).String())
	}
	if len(x.ServedFrom) > 0 {
		sb.WriteString(" served_from: [")
		for i, v := range x.ServedFrom {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SrvKeyspace) String() string {
	return x.MarshalProtoText()
}
func (x *CellInfo) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("CellInfo { ")
	if x.ServerAddress != "" {
		sb.WriteString(" server_address: ")
		sb.WriteString(strconv.Quote(x.ServerAddress))
	}
	if x.Root != "" {
		sb.WriteString(" root: ")
		sb.WriteString(strconv.Quote(x.Root))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *CellInfo) String() string {
	return x.MarshalProtoText()
}
func (x *CellsAlias) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("CellsAlias { ")
	if len(x.Cells) > 0 {
		sb.WriteString(" cells: [")
		for i, v := range x.Cells {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *CellsAlias) String() string {
	return x.MarshalProtoText()
}
func (m *KeyRange) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TabletAlias) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TabletAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TabletAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tablet) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tablet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tablet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Alias == nil {
				m.Alias = &TabletAlias{}
			}
			if err := m.Alias.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMap == nil {
				m.PortMap = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PortMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbNameOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbNameOverride = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return protobuf_go_lite.ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MysqlHostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MysqlHostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MysqlPort", wireType)
			}
			m.MysqlPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MysqlPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterTermStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MasterTermStartTime == nil {
				m.MasterTermStartTime = &vttime.Time{}
			}
			if err := m.MasterTermStartTime.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard_ServedType) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard_ServedType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard_ServedType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard_SourceShard) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard_SourceShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard_SourceShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard_TabletControl) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard_TabletControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard_TabletControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlacklistedTables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlacklistedTables = append(m.BlacklistedTables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frozen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Frozen = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterAlias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MasterAlias == nil {
				m.MasterAlias = &TabletAlias{}
			}
			if err := m.MasterAlias.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServedTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServedTypes = append(m.ServedTypes, &Shard_ServedType{})
			if err := m.ServedTypes[len(m.ServedTypes)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceShards = append(m.SourceShards, &Shard_SourceShard{})
			if err := m.SourceShards[len(m.SourceShards)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletControls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TabletControls = append(m.TabletControls, &Shard_TabletControl{})
			if err := m.TabletControls[len(m.TabletControls)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMasterServing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMasterServing = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterTermStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MasterTermStartTime == nil {
				m.MasterTermStartTime = &vttime.Time{}
			}
			if err := m.MasterTermStartTime.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyspace_ServedFrom) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyspace_ServedFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyspace_ServedFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyspace) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyspace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyspace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardingColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingColumnType", wireType)
			}
			m.ShardingColumnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardingColumnType |= KeyspaceIdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServedFroms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServedFroms = append(m.ServedFroms, &Keyspace_ServedFrom{})
			if err := m.ServedFroms[len(m.ServedFroms)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceType", wireType)
			}
			m.KeyspaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceType |= KeyspaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseKeyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseKeyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnapshotTime == nil {
				m.SnapshotTime = &vttime.Time{}
			}
			if err := m.SnapshotTime.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardReplication_Node) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardReplication_Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardReplication_Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletAlias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TabletAlias == nil {
				m.TabletAlias = &TabletAlias{}
			}
			if err := m.TabletAlias.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardReplication) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardReplication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardReplication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &ShardReplication_Node{})
			if err := m.Nodes[len(m.Nodes)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardReference) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardTabletControl) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardTabletControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardTabletControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryServiceDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryServiceDisabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrvKeyspace_KeyspacePartition) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrvKeyspace_KeyspacePartition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrvKeyspace_KeyspacePartition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServedType", wireType)
			}
			m.ServedType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServedType |= TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardReferences = append(m.ShardReferences, &ShardReference{})
			if err := m.ShardReferences[len(m.ShardReferences)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTabletControls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardTabletControls = append(m.ShardTabletControls, &ShardTabletControl{})
			if err := m.ShardTabletControls[len(m.ShardTabletControls)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrvKeyspace_ServedFrom) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrvKeyspace_ServedFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrvKeyspace_ServedFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrvKeyspace) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrvKeyspace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrvKeyspace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &SrvKeyspace_KeyspacePartition{})
			if err := m.Partitions[len(m.Partitions)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardingColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingColumnType", wireType)
			}
			m.ShardingColumnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardingColumnType |= KeyspaceIdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServedFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServedFrom = append(m.ServedFrom, &SrvKeyspace_ServedFrom{})
			if err := m.ServedFrom[len(m.ServedFrom)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellInfo) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellsAlias) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellsAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellsAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
